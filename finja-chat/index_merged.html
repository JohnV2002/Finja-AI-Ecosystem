<!-- ====================================================================== -->
<!--                      Finja's Twitch Bot & Overlay                      -->
<!-- ====================================================================== -->
<!--                                                                        -->
<!--   Project: Finja - Twitch Interactivity Suite                          -->
<!--   Author: J. Apps (JohnV2002 / Sodakiller1)                            -->
<!--   Version: 2.2.1                                                       -->
<!--   Description: Visual overlay for OBS displaying Twitch chat.          -->
<!--                                                                        -->
<!--   ‚ú® New in 2.2.1:                                                     -->
<!--     ‚Ä¢ Code Quality: All SonarQube issues resolved                      -->
<!--     ‚Ä¢ Complete English code documentation with JSDoc                   -->
<!--     ‚Ä¢ Improved accessibility: proper <dialog> element, label-for       -->
<!--     ‚Ä¢ Reduced cognitive complexity with helper functions               -->
<!--     ‚Ä¢ Modern JS: replaceAll, Number.parseInt, top-level await          -->
<!--     ‚Ä¢ Better contrast ratios for dev UI elements                       -->
<!--     ‚Ä¢ Comprehensive error handling in all catch blocks                 -->
<!--     ‚Ä¢ Standard CSS mask property added for compatibility               -->
<!--                                                                        -->
<!--   üìú Changelog 2.1.0:                                                  -->
<!--     ‚Ä¢ Enhanced theme system with glass, dark, light, neon              -->
<!--     ‚Ä¢ RGB ring and fill effects with customizable speed                -->
<!--     ‚Ä¢ BroadcastChannel communication with bot panel                    -->
<!--     ‚Ä¢ Song Request pending UI for moderators (dev mode)                -->
<!--     ‚Ä¢ Finja always stays blue regardless of accent changes             -->
<!--     ‚Ä¢ LLM response display with custom styling                         -->
<!--                                                                        -->
<!--   Copyright (c) 2026 J. Apps                                           -->
<!--   Licensed under the MIT License.                                      -->
<!-- ====================================================================== -->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Twitch Chat Overlay</title>

  <!-- ComfyJS for Twitch chat integration -->
  <script src="https://cdn.jsdelivr.net/npm/comfy.js@latest/dist/comfy.min.js"></script>

  <style>
    :root{
      --font: Inter, system-ui, Arial;
      --font-size: 26px;
      --name-weight: 700;
      --emote-size: 34px;
      --gap: 14px;
      --message-width: 64%;
      --radius: 18px;

      --bg-alpha: .70;
      --bubble-bg: rgba(20,22,30,var(--bg-alpha));
      --bubble-text:#f2f6ff;
      --bubble-sub:#b8c0d4;

      --accent:#7aa2ff; /* Finja blue */
      --accent-2:#ff6ad5;

      --glass-tex-url:none;

      /* RGB animation settings */
      --rgb-speed: 8s;
      --rgb-ring-w: 6px;
    }

    html,body{height:100%;margin:0;background:transparent}
    #overlay{width:100%;height:100%;display:flex;flex-direction:column;justify-content:flex-end;padding:16px;box-sizing:border-box}
    #chat{display:flex;flex-direction:column;gap:var(--gap)}
    #chat.top{justify-content:flex-start}

    .message{
      position:relative; max-width:var(--message-width);
      background:var(--bubble-bg); color:var(--bubble-text);
      border-radius:var(--radius); padding:10px 14px;
      font-family:var(--font); font-size:var(--font-size); line-height:1.35;
      box-sizing:border-box; backdrop-filter:blur(8px);
      transform-origin:bottom left; animation:slideUp .45s cubic-bezier(.2,.8,.2,1) both;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.45), 0 8px 26px rgba(0,0,0,.35);
    }

    /* Glass texture overlay */
    .message.glass::after{
      content:""; position:absolute; inset:0; border-radius:inherit;
      background-image:var(--glass-tex-url); background-repeat:repeat; background-size:96px 96px;
      opacity:.14; mix-blend-mode:overlay; pointer-events:none;
    }

    .message .line{display:flex;gap:8px;align-items:flex-start;flex-wrap:wrap}
    .badges{display:inline-flex;gap:4px;margin-right:2px}
    .badges .badge{height:18px}
    .message img.emote{height:var(--emote-size);vertical-align:middle}
    .username{font-weight:var(--name-weight)}
    .timestamp{margin-left:auto;opacity:.75;font-size:.85em;color:var(--bubble-sub)}
    .message .content{word-break:break-word;overflow-wrap:anywhere;flex:1 1 auto}

    /* Accent ring (static) */
    .message.accent-ring{
      outline:3px solid color-mix(in oklab,var(--accent) 65%,transparent);
      box-shadow:
        0 0 0 2px color-mix(in oklab,#000 60%,transparent) inset,
        0 6px 24px rgba(0,0,0,.35),
        0 0 18px color-mix(in oklab,var(--accent) 45%,transparent);
    }

    /* Neon base (no RGB) */
    .message.neon{
      outline-width:4px;
      box-shadow:
        0 0 0 2px color-mix(in oklab,#000 55%,transparent) inset,
        0 10px 28px rgba(0,0,0,.45);
    }
    .message.neon-glow{
      outline:4px solid color-mix(in oklab,var(--accent) 55%,transparent);
      box-shadow:
        0 0 28px color-mix(in oklab,var(--accent) 60%,transparent),
        0 8px 26px rgba(0,0,0,.45);
    }

    /* RGB hue animation */
    @property --rgba { syntax: "<angle>"; inherits: false; initial-value: 0deg; }
    @keyframes rgb-hue { to { --rgba: 360deg; } }

    /* RGB ring effect */
    .message.rgb-ring::before{
      content:"";
      position:absolute;
      inset: calc(-1 * (var(--rgb-ring-w) + 1px));
      padding: calc(var(--rgb-ring-w) + 1px);
      border-radius: calc(var(--radius) + var(--rgb-ring-w));
      background: conic-gradient(from var(--rgba),
          #ff004c,#ff7a00,#ffee00,#2bff00,#00ffff,#0055ff,#ad00ff,#ff004c);
      /* FIX: Added standard mask property for compatibility */
      -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
      -webkit-mask-composite: xor;
      mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
      mask-composite: exclude;
      filter: blur(6px) saturate(1.15);
      animation: rgb-hue var(--rgb-speed) linear infinite;
      z-index:0;
    }
    .message.rgb-ring{
      outline:3px solid transparent;
      box-shadow:
        0 10px 28px rgba(0,0,0,.45),
        0 0 18px color-mix(in oklab,var(--accent) 35%,transparent);
    }

    /* RGB fill effect */
    .message.rgb-fill::before{
      content:""; position:absolute; inset:0; border-radius:inherit;
      background:
        radial-gradient(120% 120% at 20% 50%, rgba(255,255,255,.06), transparent 60%),
        conic-gradient(from var(--rgba),
          #ff004c,#ff7a00,#ffee00,#2bff00,#00ffff,#0055ff,#ad00ff,#ff004c);
      mix-blend-mode: overlay; opacity:.40; filter: blur(10px);
      animation: rgb-hue calc(var(--rgb-speed) * 1.2) linear infinite;
      z-index:0;
    }

    .message>*{ position:relative; z-index:1 }

    .username.accent-gradient{
      background: linear-gradient(90deg,var(--accent),var(--accent-2));
      -webkit-background-clip: text; background-clip: text;
      color: transparent !important; -webkit-text-fill-color: transparent !important;
      filter: drop-shadow(0 0 2px color-mix(in oklab,var(--accent) 60%, transparent));
    }

    .message.me .content{ font-style:italic; color:var(--accent) }

    @keyframes slideUp{from{opacity:0;transform:translateY(20px) scale(.98)}to{opacity:1;transform:translateY(0) scale(1)}}

    /* Development UI badge - FIX: Improved contrast */
    #dev-badge{position:fixed;left:10px;bottom:10px;padding:6px 8px;background:#0f7a3a;color:#ffffff;font:600 12px/1 Inter,system-ui,Arial;border-radius:10px;z-index:2147483647;display:none}
    .dev #dev-badge{display:block}
    #cfg{position:fixed;right:16px;bottom:16px;z-index:2147483647;display:none}
    .dev #cfg{display:block}
    #cfg .btn{cursor:pointer;padding:10px 12px;border-radius:12px;background:#2b2f3a;color:#fff;border:0;box-shadow:0 6px 20px rgba(0,0,0,.35)}
    #cfg .sheet{display:none;position:absolute;right:0;bottom:52px;width:360px;max-height:70vh;overflow:auto;background:#161922;color:#eaf1ff;border-radius:16px;padding:12px;box-shadow:0 20px 60px rgba(0,0,0,.5)}
    #cfg.open .sheet{display:block}
    #cfg .row{display:flex;gap:8px;align-items:center;margin:8px 0}
    #cfg .row label{flex:1 1 auto;font-size:12px;opacity:.9}
    #cfg .row input[type="number"], #cfg .row input[type="text"], #cfg .row select{flex:0 0 160px;padding:6px 8px;border-radius:10px;border:1px solid #333845;background:#0f1219;color:#eaf1ff}
    #cfg .row input[type="checkbox"]{transform:scale(1.1)}
    #cfg .save{width:100%;margin-top:6px}
    #cfg .status{display:block;text-align:center;opacity:.75;margin-top:8px;font-size:12px}
    #cheatsheet{margin-top:10px;font-size:12px;background:#0f1219;border:1px solid #2b2f3a;border-radius:12px;padding:10px;line-height:1.35}
    #cheatsheet code{background:#111521;padding:1px 6px;border-radius:8px}

    /* Finja always stays Finja blue */
    .message.finja{
      --accent:#7aa2ff !important;
      --accent-2:#ff6ad5 !important;
      outline:3px solid color-mix(in oklab,var(--accent) 65%,transparent) !important;
      box-shadow:
        0 0 0 2px color-mix(in oklab,#000 60%,transparent) inset,
        0 6px 24px rgba(0,0,0,.35),
        0 0 18px color-mix(in oklab,var(--accent) 45%,transparent) !important;
    }
    .message.finja.rgb-ring::before,
    .message.finja.rgb-fill::before{ display:none !important; }
    .message.finja .username{
      background: linear-gradient(90deg,#7aa2ff,#ff6ad5);
      -webkit-background-clip: text; background-clip: text;
      color: transparent !important; -webkit-text-fill-color: transparent !important;
      filter: drop-shadow(0 0 2px color-mix(in oklab,#7aa2ff 60%, transparent));
    }

    /* Pulse animation */
    @keyframes pulse-accent{0%,100%{outline-color:color-mix(in oklab,var(--accent) 75%,transparent)}50%{outline-color:color-mix(in oklab,var(--accent) 45%,transparent)}}
    .message.pulse{animation:slideUp .45s cubic-bezier(.2,.8,.2,1) both,pulse-accent 1.5s ease-in-out infinite}

    /* LLM response styling */
    .message.llm-response{
      outline:3px solid color-mix(in oklab,#a78bfa 65%,transparent);
      box-shadow:
        0 0 0 2px color-mix(in oklab,#000 60%,transparent) inset,
        0 6px 24px rgba(0,0,0,.35),
        0 0 18px color-mix(in oklab,#a78bfa 45%,transparent);
    }
    .message.llm-response .username{
      background: linear-gradient(90deg,#a78bfa,#ec4899);
      -webkit-background-clip: text; background-clip: text;
      color: transparent !important; -webkit-text-fill-color: transparent !important;
    }
  </style>
</head>
<body>
  <div id="dev-badge">DEV MODE</div>
  <div id="overlay">
    <div id="chat"></div>
  </div>

  <!-- Development configuration panel -->
  <div id="cfg">
    <button class="btn" id="cfgToggle">‚öôÔ∏è</button>
    <div class="sheet">
      <div class="row">
        <label for="cfgChannel">Channel</label>
        <input type="text" id="cfgChannel" />
      </div>
      <div class="row">
        <label for="cfgTheme">Theme</label>
        <select id="cfgTheme">
          <option value="glass">Glass</option>
          <option value="dark">Dark</option>
          <option value="light">Light</option>
          <option value="neon">Neon</option>
        </select>
      </div>
      <div class="row">
        <label for="cfgRgb">RGB</label>
        <select id="cfgRgb">
          <option value="off">Off</option>
          <option value="ring">Ring</option>
          <option value="fill">Fill</option>
          <option value="both">Both</option>
        </select>
      </div>
      <div class="row">
        <label for="cfgRgbSpeed">RGB Speed (s)</label>
        <input type="number" id="cfgRgbSpeed" min="2" max="30" />
      </div>
      <div class="row">
        <label for="cfgRing">Ring Width</label>
        <input type="number" id="cfgRing" min="6" max="10" />
      </div>
      <div class="row">
        <label for="cfgOpacity">Opacity</label>
        <input type="number" id="cfgOpacity" min="0" max="100" />
      </div>
      <div class="row">
        <label for="cfgPulse">Pulse</label>
        <input type="checkbox" id="cfgPulse" />
      </div>
      <div class="row">
        <label for="cfgAccent">Accent</label>
        <select id="cfgAccent">
          <option value="finja">Finja</option>
          <option value="channel">Channel</option>
          <option value="custom">Custom</option>
        </select>
      </div>
      <div class="row">
        <label for="cfgAccentHex">Custom Accent</label>
        <input type="text" id="cfgAccentHex" placeholder="#7aa2ff" />
      </div>
      <button class="btn save" id="cfgSave">Save</button>
      <button class="btn save" id="cfgCopy">Copy OBS Link</button>
      <span class="status" id="cfgStatus"></span>
      <div id="cheatsheet">
        Add <code>?dev=1</code> to URL for dev mode.<br>
        Add <code>?channel=name</code> to set channel.
      </div>
    </div>
  </div>

  <script type="module">
    "use strict";

    /* ========== Constants ========== */
    const MAX_MESSAGES = 50;                    // Maximum chat messages to display
    const MESSAGE_FADE_DURATION = 450;          // Fade animation duration in ms
    const LLM_MESSAGE_DURATION = 15000;         // LLM response display time in ms
    const SR_REFRESH_INTERVAL = 8000;           // Song request refresh interval in ms
    const HELP_PANEL_DEFAULT_TTL = 9000;        // Help panel display duration in ms
    const HELP_PANEL_MIN_TTL = 2000;            // Minimum help panel display time in ms
    const EMOTE_REGEX_COMPLEXITY_LIMIT = 20;    // Max regex complexity for emotes
    const STORAGE_KEY = "finja-overlay-config";
    
    /* ========== Configuration ========== */
    /**
     * Global configuration object loaded from URL parameters and localStorage
     * Controls overlay appearance and behavior
     */
    const CONFIG = {
      channel: "",
      theme: "glass",
      rgb: "off",
      rgbspeed: 15,
      ring: 8,
      opacity: 100,
      pulse: false,
      accent: "finja",
      accentHex: "",
      botDisplayName: "finja_chat_bot"
    };

    /* ========== Global State ========== */
    const chatContainer = document.getElementById("chat");
    const emoteCache = {};  // Cache for Twitch/BTTV/FFZ emotes
    let broadcasterColor = null;

    /* ========== Helper Functions ========== */
    /**
     * Shorthand for document.getElementById
     * @param {string} id - Element ID
     * @returns {HTMLElement|null}
     */
    const $ = (id) => document.getElementById(id);

    /**
     * Escapes special regex characters in a string
     * @param {string} s - String to escape
     * @returns {string} Escaped string safe for use in RegExp
     */
    const escapeRegex = (s) => s.replaceAll(/[.*+?^${}()|[\]\\]/g, String.raw`\$&`);

    /**
     * Parses URL query parameters into CONFIG object
     * Handles all configuration options from URL
     */
    function parseUrlParams() {
      const params = new URLSearchParams(globalThis.location.search || "");
      
      if (params.has("channel")) {
        CONFIG.channel = params.get("channel");
      }
      if (params.has("theme")) {
        CONFIG.theme = params.get("theme");
      }
      if (params.has("rgb")) {
        CONFIG.rgb = params.get("rgb");
      }
      if (params.has("rgbspeed")) {
        CONFIG.rgbspeed = Number.parseInt(params.get("rgbspeed"), 10) || 15;
      }
      if (params.has("ring")) {
        CONFIG.ring = Number.parseInt(params.get("ring"), 10) || 8;
      }
      if (params.has("opacity")) {
        CONFIG.opacity = Number.parseInt(params.get("opacity"), 10) || 100;
      }
      if (params.has("pulse")) {
        CONFIG.pulse = params.get("pulse") === "on";
      }
      if (params.has("accent")) {
        CONFIG.accent = params.get("accent");
      }
      if (params.has("accentHex")) {
        CONFIG.accentHex = params.get("accentHex");
      }

      // Dev mode detection
      if (params.get("dev") === "1") {
        document.body.classList.add("dev");
      }
    }

    /**
     * Loads saved configuration from localStorage
     * Falls back to URL params if no saved config exists
     */
    function loadSavedConfig() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          const parsed = JSON.parse(saved);
          Object.assign(CONFIG, parsed);
        }
      } catch (error) {
        console.warn("Failed to load saved config:", error);
      }
    }

    /**
     * Applies current theme configuration to DOM
     * Updates CSS custom properties and element classes
     */
    function applyTheme() {
      const root = document.documentElement;
      
      // Apply opacity
      root.style.setProperty("--bg-alpha", (CONFIG.opacity / 100) * 0.7);
      
      // Apply RGB speed
      root.style.setProperty("--rgb-speed", `${CONFIG.rgbspeed}s`);
      
      // Apply ring width
      root.style.setProperty("--rgb-ring-w", `${CONFIG.ring}px`);

      // Apply accent color
      applyAccentColor();

      // Set chat alignment for top theme
      if (CONFIG.theme === "top") {
        chatContainer.classList.add("top");
      } else {
        chatContainer.classList.remove("top");
      }
    }

    /**
     * Applies accent color based on configuration
     * Handles finja, channel, and custom color modes
     */
    function applyAccentColor() {
      const root = document.documentElement;
      
      if (CONFIG.accent === "finja") {
        root.style.setProperty("--accent", "#7aa2ff");
        root.style.setProperty("--accent-2", "#ff6ad5");
      } else if (CONFIG.accent === "channel" && broadcasterColor) {
        root.style.setProperty("--accent", broadcasterColor);
      } else if (CONFIG.accent === "custom" && CONFIG.accentHex) {
        root.style.setProperty("--accent", CONFIG.accentHex);
      }
    }

    /**
     * Fetches and caches Twitch emotes for a channel
     * @param {string} channel - Twitch channel name
     */
    async function loadEmotes(channel) {
      if (!channel) {
        return;
      }

      const emoteCacheKey = `emotes_${channel}`;
      
      try {
        const response = await fetch(`https://api.ivr.fi/v2/twitch/emotes/${channel}`, { 
          cache: "no-store" 
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        
        const data = await response.json();
        emoteCache[emoteCacheKey] = data;
      } catch (error) {
        console.warn("Failed to load emotes:", error);
      }
    }

    /**
     * Tokenizes message text into text and emote segments
     * Handles Twitch, BTTV, and FFZ emotes
     * 
     * @param {string} rawText - Raw message text
     * @param {Array} messageEmotes - Emote data from Twitch
     * @returns {Array} Array of tokens with type, value, and optional src/alt
     */
    function tokenizeEmotes(rawText, messageEmotes) {
      const tokens = [];
      const emotePositions = [];

      // Parse Twitch native emotes
      if (messageEmotes && messageEmotes.length > 0) {
        messageEmotes.forEach(emote => {
          const [start, end] = emote.positions[0].split("-").map(n => Number.parseInt(n, 10));
          emotePositions.push({
            start,
            end: end + 1,
            id: emote.id,
            name: rawText.substring(start, end + 1)
          });
        });
      }

      // Sort by position
      emotePositions.sort((a, b) => a.start - b.start);

      let cursor = 0;
      
      for (const emote of emotePositions) {
        // Add text before emote
        if (cursor < emote.start) {
          const textSegment = rawText.substring(cursor, emote.start);
          tokens.push({ t: "text", v: textSegment });
        }
        
        // Add emote
        tokens.push({
          t: "emote",
          src: `https://static-cdn.jtvnw.net/emoticons/v2/${emote.id}/default/dark/2.0`,
          alt: emote.name
        });
        
        cursor = emote.end;
      }

      // Add remaining text
      if (cursor < rawText.length) {
        tokens.push({ t: "text", v: rawText.substring(cursor) });
      }

      return processThirdPartyEmotes(tokens);
    }

    /**
     * Processes tokens to replace text with third-party emotes
     * Handles BTTV and FFZ emotes
     * 
     * @param {Array} tokens - Array of text/emote tokens
     * @returns {Array} Processed tokens with third-party emotes
     */
    function processThirdPartyEmotes(tokens) {
      const emoteCacheKey = `emotes_${CONFIG.channel}`;
      const emoteData = emoteCache[emoteCacheKey];
      
      if (!emoteData) {
        return tokens;
      }

      const result = [];
      
      for (const token of tokens) {
        if (token.t !== "text") {
          result.push(token);
          continue;
        }

        const words = token.v.split(/(\s+)/);
        
        for (const word of words) {
          if (word.match(/^\s+$/)) {
            result.push({ t: "text", v: word });
            continue;
          }

          const emote = findEmoteByName(emoteData, word);
          
          if (emote) {
            result.push({
              t: "emote",
              src: emote.url,
              alt: word
            });
          } else {
            result.push({ t: "text", v: word });
          }
        }
      }

      return result;
    }

    /**
     * Finds an emote by name in cached emote data
     * @param {Object} emoteData - Cached emote data
     * @param {string} name - Emote name to find
     * @returns {Object|null} Emote object or null
     */
    function findEmoteByName(emoteData, name) {
      // Check channel emotes
      if (emoteData.channel) {
        const found = emoteData.channel.find(e => e.name === name);
        if (found) {
          return { url: found.urls[2] || found.urls[0] };
        }
      }

      // Check shared emotes
      if (emoteData.shared) {
        const found = emoteData.shared.find(e => e.name === name);
        if (found) {
          return { url: found.urls[2] || found.urls[0] };
        }
      }

      return null;
    }

    /**
     * Renders tokens to HTML elements
     * @param {Array} tokens - Array of tokens to render
     * @returns {DocumentFragment} Fragment containing rendered elements
     */
    function renderTokens(tokens) {
      const fragment = document.createDocumentFragment();
      
      for (const token of tokens) {
        if (token.t === "emote") {
          const img = document.createElement("img");
          img.className = "emote";
          img.src = token.src;
          img.alt = token.alt;
          fragment.appendChild(img);
        } else {
          fragment.appendChild(document.createTextNode(token.v));
        }
      }
      
      return fragment;
    }

    /**
     * Adds a chat message to the overlay
     * Main message rendering function
     * 
     * @param {string} user - Username
     * @param {string} message - Message text
     * @param {Object} flags - User flags (mod, subscriber, etc.)
     * @param {Object} extra - Additional data (color, badges, emotes)
     */
    function addMessageFromComfy(user, message, flags, extra) {
      const isFinja = user.toLowerCase() === "finja_chat_bot";
      
      // Create message container
      const msgDiv = document.createElement("div");
      msgDiv.className = buildMessageClasses(isFinja, flags);

      // Create message line
      const line = document.createElement("div");
      line.className = "line";

      // Add badges
      if (extra.userBadges) {
        addBadgesToLine(line, extra.userBadges);
      }

      // Add username
      const usernameSpan = createUsernameElement(user, extra, isFinja, flags);
      line.appendChild(usernameSpan);

      // Add separator
      line.appendChild(document.createTextNode(": "));

      // Add message content
      const contentSpan = document.createElement("span");
      contentSpan.className = "content";
      
      const tokens = tokenizeEmotes(message, extra.messageEmotes || []);
      contentSpan.appendChild(renderTokens(tokens));
      
      line.appendChild(contentSpan);

      // Add timestamp
      const timestampSpan = document.createElement("span");
      timestampSpan.className = "timestamp";
      timestampSpan.textContent = new Date().toLocaleTimeString("en-US", { 
        hour: "2-digit", 
        minute: "2-digit" 
      });
      line.appendChild(timestampSpan);

      msgDiv.appendChild(line);
      chatContainer.appendChild(msgDiv);

      // Remove old messages if limit exceeded
      trimMessages();
    }

    /**
     * Builds CSS classes for message element
     * @param {boolean} isFinja - Is message from Finja bot
     * @param {Object} flags - User flags
     * @returns {string} Space-separated class names
     */
    function buildMessageClasses(isFinja, flags) {
      const classes = ["message"];
      
      if (isFinja) {
        classes.push("finja");
      } else {
        applyThemeClasses(classes);
      }

      if (flags && flags.broadcaster) {
        classes.push("me");
      }

      return classes.join(" ");
    }

    /**
     * Applies theme-specific classes to message
     * @param {Array} classes - Array to add classes to
     */
    function applyThemeClasses(classes) {
      const theme = CONFIG.theme;
      const rgb = CONFIG.rgb;

      if (theme === "glass") {
        classes.push("glass", "accent-ring");
      } else if (theme === "neon") {
        classes.push("neon-glow");
      } else {
        classes.push(theme);
      }

      // RGB effects
      if (rgb === "ring") {
        classes.push("rgb-ring");
      } else if (rgb === "fill") {
        classes.push("rgb-fill");
      } else if (rgb === "both") {
        classes.push("rgb-ring", "rgb-fill");
      }

      // Pulse animation
      if (CONFIG.pulse) {
        classes.push("pulse");
      }
    }

    /**
     * Adds badge images to message line
     * @param {HTMLElement} line - Line element to add badges to
     * @param {Object} userBadges - Badge data from Twitch
     */
    function addBadgesToLine(line, userBadges) {
      const badgesDiv = document.createElement("div");
      badgesDiv.className = "badges";
      
      for (const [badgeType, badgeVersion] of Object.entries(userBadges)) {
        const badgeImg = document.createElement("img");
        badgeImg.className = "badge";
        badgeImg.src = `https://static-cdn.jtvnw.net/badges/v1/${getBadgeId(badgeType, badgeVersion)}/2`;
        badgeImg.alt = badgeType;
        badgesDiv.appendChild(badgeImg);
      }
      
      line.appendChild(badgesDiv);
    }

    /**
     * Gets badge ID for Twitch badge URL
     * @param {string} badgeType - Type of badge
     * @param {string} badgeVersion - Badge version
     * @returns {string} Badge ID for URL
     */
    function getBadgeId(badgeType, badgeVersion) {
      // Simplified badge ID mapping
      return `${badgeType}/${badgeVersion}`;
    }

    /**
     * Creates username span element with styling
     * @param {string} user - Username
     * @param {Object} extra - Extra user data
     * @param {boolean} isFinja - Is Finja bot
     * @param {Object} flags - User flags
     * @returns {HTMLElement} Username span element
     */
    function createUsernameElement(user, extra, isFinja, flags) {
      const span = document.createElement("span");
      span.className = "username";
      
      if (isFinja || (CONFIG.accent === "channel" && flags && flags.broadcaster)) {
        span.classList.add("accent-gradient");
      }
      
      if (extra.userColor && !isFinja) {
        span.style.color = extra.userColor;
      }
      
      span.textContent = extra.displayName || user;
      
      return span;
    }

    /**
     * Removes old messages if limit is exceeded
     * Keeps only MAX_MESSAGES most recent messages
     */
    function trimMessages() {
      while (chatContainer.children.length > MAX_MESSAGES) {
        const oldMsg = chatContainer.firstChild;
        oldMsg.remove();
      }
    }

    /**
     * Handles remote commands from bot via BroadcastChannel
     * Applies visual changes to overlay
     * 
     * @param {string} cmd - Command name
     * @param {string} arg - Command argument
     * @param {Object} flags - User flags
     */
    function applyRemoteCommand(cmd, arg, flags) {
      const lowCmd = cmd.toLowerCase();
      const lowArg = String(arg || "").toLowerCase();

      switch (lowCmd) {
        case "theme":
          handleThemeCommand(lowArg);
          break;
        case "rgb":
          handleRgbCommand(lowArg);
          break;
        case "rgbspeed":
          handleRgbSpeedCommand(lowArg);
          break;
        case "ring":
          handleRingCommand(lowArg);
          break;
        case "opacity":
          handleOpacityCommand(lowArg);
          break;
        case "pulse":
          handlePulseCommand(lowArg);
          break;
        case "accent":
          handleAccentCommand(lowArg);
          break;
        default:
          console.warn("Unknown command:", lowCmd);
      }
    }

    /**
     * Handles theme change command
     * @param {string} theme - Theme name
     */
    function handleThemeCommand(theme) {
      if (["glass", "dark", "light", "neon"].includes(theme)) {
        CONFIG.theme = theme;
        applyTheme();
      }
    }

    /**
     * Handles RGB mode command
     * @param {string} arg - RGB mode and optional ring width
     */
    function handleRgbCommand(arg) {
      const parts = arg.split(/\s+/);
      const mode = parts[0];
      
      if (["off", "ring", "fill", "both"].includes(mode)) {
        CONFIG.rgb = mode;
        
        if (parts[1]) {
          const width = Number.parseInt(parts[1], 10);
          if (width >= 6 && width <= 10) {
            CONFIG.ring = width;
          }
        }
        
        applyTheme();
      }
    }

    /**
     * Handles RGB speed command
     * @param {string} speed - Speed value
     */
    function handleRgbSpeedCommand(speed) {
      const val = Number.parseInt(speed, 10);
      if (val >= 2 && val <= 30) {
        CONFIG.rgbspeed = val;
        applyTheme();
      }
    }

    /**
     * Handles ring width command
     * @param {string} width - Ring width value
     */
    function handleRingCommand(width) {
      const val = Number.parseInt(width, 10);
      if (val >= 6 && val <= 10) {
        CONFIG.ring = val;
        applyTheme();
      }
    }

    /**
     * Handles opacity command
     * @param {string} opacity - Opacity value
     */
    function handleOpacityCommand(opacity) {
      const val = Number.parseInt(opacity, 10);
      if (val >= 0 && val <= 100) {
        CONFIG.opacity = val;
        applyTheme();
      }
    }

    /**
     * Handles pulse animation command
     * @param {string} state - on or off
     */
    function handlePulseCommand(state) {
      if (state === "on" || state === "off") {
        CONFIG.pulse = state === "on";
        applyTheme();
      }
    }

    /**
     * Handles accent color command
     * @param {string} arg - Accent mode and optional hex color
     */
    function handleAccentCommand(arg) {
      const parts = arg.split(/\s+/);
      const mode = parts[0];
      
      if (["finja", "channel"].includes(mode)) {
        CONFIG.accent = mode;
        CONFIG.accentHex = "";
        applyTheme();
      } else if (mode === "custom" && parts[1] && parts[1].match(/^#[0-9a-f]{6}$/i)) {
        CONFIG.accent = "custom";
        CONFIG.accentHex = parts[1];
        applyTheme();
      }
    }

    /* ========== BroadcastChannel Integration ========== */
    /**
     * Sets up BroadcastChannel listener for bot communication
     * Handles visual commands, LLM responses, and help panel
     */
    function setupBroadcastChannel() {
      let bc;
      
      try {
        bc = new BroadcastChannel("finja-overlay");
      } catch (error) {
        console.warn("BroadcastChannel not available:", error);
        return;
      }

      bc.onmessage = (ev) => {
        const data = ev.data || {};
        
        if (data.type === "visual" && data.cmd) {
          applyRemoteCommand(data.cmd, data.arg, data.flags);
        } else if (data.type === "llm-response") {
          handleLLMResponse(data);
        } else if (data.type === "chat") {
          handleBroadcastChat(data);
        } else if (data.type === "accent" && data.value) {
          handleAccentBroadcast(data.value);
        }
      };
    }

    /**
     * Handles LLM response from bot
     * @param {Object} data - LLM response data
     */
    function handleLLMResponse(data) {
      const msg = `ü§ñ ${data.answer}`;
      
      addMessageFromComfy(
        data.user,
        msg,
        { broadcaster: false },
        {
          displayName: "Finja AI",
          userColor: "#a78bfa",
          messageEmotes: [],
          userBadges: {}
        }
      );

      // Auto-remove after duration
      setTimeout(() => {
        const messages = chatContainer.querySelectorAll(".message.llm-response");
        if (messages.length > 0) {
          messages[0].remove();
        }
      }, LLM_MESSAGE_DURATION);
    }

    /**
     * Handles chat message from BroadcastChannel
     * @param {Object} data - Chat message data
     */
    function handleBroadcastChat(data) {
      addMessageFromComfy(
        data.user,
        data.message,
        data.flags || {},
        data.extra || { displayName: data.user, messageEmotes: [] }
      );
    }

    /**
     * Handles accent color broadcast
     * @param {string} color - Hex color value
     */
    function handleAccentBroadcast(color) {
      document.documentElement.style.setProperty("--accent", color);
      localStorage.setItem("finja_accent", color);
    }

    /* ========== ComfyJS Event Handlers ========== */
    /**
     * Fired when ComfyJS connects to Twitch chat
     */
    ComfyJS.onConnected = (addr, port, isFirstConnect) => {
      console.log(`Connected to ${addr}:${port}`);
    };

    /**
     * Fired for every chat message
     */
    ComfyJS.onChat = (user, message, flags, self, extra) => {
      if (self) {
        return;
      }

      // Store broadcaster color
      if (flags && flags.broadcaster && extra.userColor) {
        broadcasterColor = extra.userColor;
        if (CONFIG.accent === "channel") {
          applyAccentColor();
        }
      }

      addMessageFromComfy(user, message, flags, extra);
    };

    /* ========== Development Configuration Panel ========== */
    /**
     * Sets up the development configuration panel
     * Only visible when ?dev=1 is in URL
     */
    function setupDevPanel() {
      const cfg = $("cfg");
      const toggle = $("cfgToggle");
      const saveBtn = $("cfgSave");
      const copyBtn = $("cfgCopy");
      
      if (!cfg || !toggle || !saveBtn || !copyBtn) {
        return;
      }

      const setStatus = (text) => {
        const status = $("cfgStatus");
        if (status) {
          status.textContent = text;
        }
      };

      const syncFromConfig = () => {
        $("cfgChannel").value = CONFIG.channel || "";
        $("cfgTheme").value = CONFIG.theme || "glass";
        $("cfgRgb").value = CONFIG.rgb || "off";
        $("cfgRgbSpeed").value = CONFIG.rgbspeed || 15;
        $("cfgRing").value = CONFIG.ring || 8;
        $("cfgOpacity").value = CONFIG.opacity || 100;
        $("cfgPulse").checked = CONFIG.pulse || false;
        $("cfgAccent").value = CONFIG.accent || "finja";
        $("cfgAccentHex").value = CONFIG.accentHex || "";
      };

      const readIntoConfig = () => {
        CONFIG.channel = $("cfgChannel").value.trim();
        CONFIG.theme = $("cfgTheme").value;
        CONFIG.rgb = $("cfgRgb").value;
        CONFIG.rgbspeed = Number.parseInt($("cfgRgbSpeed").value, 10) || 15;
        CONFIG.ring = Number.parseInt($("cfgRing").value, 10) || 8;
        CONFIG.opacity = Number.parseInt($("cfgOpacity").value, 10) || 100;
        CONFIG.pulse = $("cfgPulse").checked;
        CONFIG.accent = $("cfgAccent").value;
        CONFIG.accentHex = $("cfgAccentHex").value.trim();

        if (CONFIG.channel && CONFIG.channel !== "") {
          loadEmotes(CONFIG.channel);
        }
      };

      const buildObsUrl = () => {
        const base = globalThis.location.origin + globalThis.location.pathname;
        const params = new URLSearchParams({
          channel: CONFIG.channel || "",
          theme: CONFIG.theme || "glass",
          rgb: CONFIG.rgb || "off",
          rgbspeed: String(CONFIG.rgbspeed || 15),
          ring: String(CONFIG.ring || 8),
          opacity: String(CONFIG.opacity || 100),
          pulse: CONFIG.pulse ? "on" : "off",
          accent: CONFIG.accent || "finja",
          accentHex: CONFIG.accentHex || ""
        });
        return `${base}?${params.toString()}`;
      };

      toggle.onclick = () => cfg.classList.toggle("open");
      syncFromConfig();

      saveBtn.onclick = () => {
        readIntoConfig();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(CONFIG));
        applyTheme();
        setStatus("‚úî Saved (LocalStorage)");
      };

      copyBtn.onclick = async () => {
        readIntoConfig();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(CONFIG));
        applyTheme();
        const url = buildObsUrl();
        
        try {
          await navigator.clipboard.writeText(url);
          setStatus("üîó Link copied!");
        } catch (error) {
          console.warn("Clipboard API failed, using fallback:", error);
          globalThis.prompt("Copy this link for OBS:", url);
        }
      };
    }

    /* ========== Initialization ========== */
    /**
     * Shows confirmation message from URL parameter
     * Displayed once after page reload with ?confirm= parameter
     */
    function showConfirmOnce() {
      try {
        const msg = new URLSearchParams(globalThis.location.search || "").get("confirm");
        if (!msg) {
          return;
        }
        
        setTimeout(() => {
          addMessageFromComfy(
            CONFIG.botDisplayName || "finja_chat_bot",
            msg,
            { broadcaster: true },
            {
              displayName: CONFIG.botDisplayName || "finja_chat_bot",
              messageEmotes: []
            }
          );
        }, 5000);
      } catch (error) {
        console.warn("Failed to show confirm message:", error);
      }
    }

    /**
     * Main initialization function
     * Runs when DOM is ready
     */
    async function initialize() {
      parseUrlParams();
      loadSavedConfig();
      applyTheme();
      setupBroadcastChannel();
      setupDevPanel();
      showConfirmOnce();

      // Load emotes if channel is configured
      if (CONFIG.channel) {
        await loadEmotes(CONFIG.channel);
      }

      // Connect to Twitch chat if channel is configured
      if (CONFIG.channel) {
        ComfyJS.Init("justinfan12345", undefined, CONFIG.channel);
      }
    }

    // Start initialization when DOM is ready
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", async () => {
        await initialize();
      });
    } else {
      // Top-level await is allowed in modules
      await initialize();
    }
  </script>

<!-- Song Request Pending Box (DEV MODE ONLY) -->
<style>
#srPendingBox{
  position:fixed; right:16px; bottom: var(--srbox-bottom, 160px); z-index:2147483000;
  max-width: 520px; font: 14px/1.35 Inter, system-ui, Arial;
  background: rgba(12,14,20,.78); color:#eaf1ff;
  border:1px solid rgba(120,140,200,.18); border-radius:14px; padding:12px 14px;
  box-shadow: 0 8px 28px rgba(0,0,0,.35);
}
#srPendingBox .title{ font-weight:700; color:#7aa2ff; margin-bottom:8px; display:flex; align-items:center; gap:8px }
#srPendingBox .item{ opacity:.98; display:flex; align-items:center; gap:8px; padding:6px 0; border-bottom:1px dashed rgba(255,255,255,.08) }
#srPendingBox .item:last-child{ border-bottom:none }
#srPendingBox .id{ color:#9bb0ff; min-width: 36px }
#srPendingBox .meta{ flex:1 }
#srPendingBox .who{ opacity:.75 }
#srPendingBox .btns{ display:flex; gap:6px }
#srPendingBox button.srBtn{
  cursor:pointer; border:none; border-radius:10px; padding:6px 10px;
  background:#1a2033; color:#eaf1ff; transition: transform .05s ease;
}
#srPendingBox button.srBtn.yes{ background:#2a4; }
#srPendingBox button.srBtn.no{ background:#c33; }
#srPendingBox button.srBtn:disabled{ opacity:.6; cursor:not-allowed }
#srPendingBox[hidden]{ display:none !important; }
</style>
<div id="srPendingBox" hidden aria-live="polite">
  <div class="title">
    <span>üéß Pending Requests</span>
    <small style="opacity:.7">DEV</small>
  </div>
  <div id="srPendingList"></div>
</div>
<script>
(function setupSRPendingBox() {
  const devMode = new URLSearchParams(globalThis.location.search || "").get("dev") === "1";
  const BOX = document.getElementById("srPendingBox");
  const LIST = document.getElementById("srPendingList");
  const PENDING_URL = "http://127.0.0.1:8099/pending";
  const CHAT_URL = "http://127.0.0.1:8099/chat";

  let bc;
  try {
    bc = new BroadcastChannel("finja-overlay");
  } catch (error) {
    console.warn("BroadcastChannel not available:", error);
  }

  if (!devMode) {
    BOX.hidden = true;
    return;
  }
  
  BOX.hidden = false;

  /**
   * Creates a DOM element with optional class
   * @param {string} tag - Element tag name
   * @param {string} cls - Optional class name
   * @returns {HTMLElement}
   */
  function createElement(tag, cls) {
    const elem = document.createElement(tag);
    if (cls) {
      elem.className = cls;
    }
    return elem;
  }

  /**
   * Fetches and displays pending song requests
   */
  async function refreshPendingList() {
    LIST.textContent = "Loading...";
    
    try {
      const response = await fetch(PENDING_URL);
      const data = await response.json();
      const items = data?.pending || [];
      
      LIST.innerHTML = "";
      
      if (items.length === 0) {
        const emptyMsg = createElement("div", "item");
        emptyMsg.textContent = "‚Äî empty ‚Äî";
        LIST.appendChild(emptyMsg);
        return;
      }

      for (const item of items) {
        const row = createPendingItem(item);
        LIST.appendChild(row);
      }
    } catch (error) {
      LIST.textContent = "‚ö†Ô∏è Failed to load";
      console.warn("Pending list load failed:", error);
    }
  }

  /**
   * Creates a pending item DOM element
   * @param {Object} item - Pending item data
   * @returns {HTMLElement}
   */
  function createPendingItem(item) {
    const row = createElement("div", "item");
    
    const id = createElement("div", "id");
    id.textContent = `#${item.id}`;
    
    const meta = createElement("div", "meta");
    const title = createElement("div", "title");
    title.textContent = item.title;
    const who = createElement("div", "who");
    who.textContent = `by ${item.user}`;
    meta.appendChild(title);
    meta.appendChild(who);
    
    const btns = createElement("div", "btns");
    const acceptBtn = createActionButton("Accept", "yes", item.id, "accept");
    const denyBtn = createActionButton("Deny", "no", item.id, "deny");
    btns.appendChild(acceptBtn);
    btns.appendChild(denyBtn);
    
    row.appendChild(id);
    row.appendChild(meta);
    row.appendChild(btns);
    
    return row;
  }

  /**
   * Creates an action button (Accept/Deny)
   * @param {string} text - Button text
   * @param {string} cls - Button class
   * @param {number} itemId - Item ID
   * @param {string} action - Action type
   * @returns {HTMLElement}
   */
  function createActionButton(text, cls, itemId, action) {
    const btn = createElement("button", `srBtn ${cls}`);
    btn.textContent = text;
    
    btn.onclick = async () => {
      btn.disabled = true;
      const siblingBtn = btn.parentElement.querySelector(`.srBtn:not(.${cls})`);
      if (siblingBtn) {
        siblingBtn.disabled = true;
      }
      
      await sendSRAction(action, itemId);
      await refreshPendingList();
    };
    
    return btn;
  }

  /**
   * Sends action to SR server
   * @param {string} action - accept or deny
   * @param {number} itemId - Item ID
   */
  async function sendSRAction(action, itemId) {
    const message = `!${action} ${itemId}`;
    
    try {
      await fetch(CHAT_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          user: "overlay",
          message: message,
          is_mod: true,
          is_broadcaster: true
        })
      });

      if (bc) {
        const announceText = action === "accept" 
          ? `ACCEPT: Song queued`
          : `DENY: Request rejected`;
        
        try {
          bc.postMessage({ type: "sr-announce", text: announceText });
        } catch (error) {
          console.warn("Failed to send BC message:", error);
        }
      }
    } catch (error) {
      console.warn("SR action failed:", error);
    }
  }

  refreshPendingList();
  setInterval(refreshPendingList, SR_REFRESH_INTERVAL);
})();
</script>

<!-- Help Panel (BroadcastChannel) -->
<style>
  #helpPanel{
    position: fixed; right: 16px; top: 16px; z-index: 2147483600;
    width: min(640px, 90vw);
    background: rgba(12,14,20,.86);
    color: #eaf1ff;
    border:1px solid rgba(120,140,200,.18);
    border-radius: 14px;
    padding: 12px 14px;
    box-shadow: 0 10px 36px rgba(0,0,0,.35);
    backdrop-filter: blur(6px);
    display:none;
  }
  #helpPanel .hp-title{
    font: 700 16px/1.2 Inter, system-ui, Arial; color:#7aa2ff; margin-bottom:8px; display:flex; align-items:center; gap:8px;
  }
  #helpPanel .hp-list{ display: grid; gap: 6px; }
  #helpPanel .hp-item{
    font: 14px/1.35 Inter, system-ui, Arial;
    background: rgba(255,255,255,.04);
    border:1px solid rgba(255,255,255,.06);
    border-radius:10px; padding:8px 10px;
  }
</style>
<dialog id="helpPanel" aria-label="Commands">
  <div class="hp-title">üß≠ Commands</div>
  <div class="hp-list" id="helpPanelList"></div>
</dialog>
<script>
(function setupHelpPanel() {
  let bc;
  
  try {
    bc = new BroadcastChannel("finja-overlay");
  } catch (error) {
    console.warn("BroadcastChannel not available:", error);
    return;
  }

  const panel = document.getElementById("helpPanel");
  const list = document.getElementById("helpPanelList");
  let hideTimer;

  bc.onmessage = (ev) => {
    const data = ev.data || {};
    
    if (data.type === "help" && Array.isArray(data.lines)) {
      const title = panel.querySelector(".hp-title");
      if (title) {
        title.textContent = data.title || "Commands";
      }
      
      // FIX: Use replaceAll instead of replace with regex
      const sanitizedLines = data.lines.map(t => 
        String(t).replaceAll("<", "&lt;").replaceAll(">", "&gt;")
      );
      
      list.innerHTML = sanitizedLines
        .map(t => `<div class="hp-item">${t}</div>`)
        .join("");
      
      panel.style.display = "block";
      clearTimeout(hideTimer);
      
      const ttl = Math.max(
        HELP_PANEL_MIN_TTL,
        Number.parseInt(data.ttl || String(HELP_PANEL_DEFAULT_TTL), 10)
      );
      
      hideTimer = setTimeout(() => {
        panel.style.display = "none";
      }, ttl);
    }
  };
})();
</script>

<!-- Attribution (visible in dev mode) -->
<style>
  #attribution {
    position: fixed;
    left: 10px;
    top: 10px;
    padding: 8px 12px;
    background: rgba(12, 14, 20, 0.8);
    color: #eaf1ff;
    font: 11px/1.4 Inter, system-ui, Arial;
    border-radius: 10px;
    border: 1px solid rgba(122, 162, 255, 0.3);
    z-index: 2147483646;
    display: none;
    backdrop-filter: blur(6px);
  }
  .dev #attribution {
    display: block;
  }
  #attribution a {
    color: #7aa2ff;
    text-decoration: none;
    font-weight: 600;
  }
  #attribution a:hover {
    text-decoration: underline;
  }
</style>
<div id="attribution">
  Made with ‚ù§Ô∏è by <a href="https://twitch.tv/sodakiller1" target="_blank">Sodakiller1</a> (J. Apps / JohnV2002)
  <br>
  <span style="opacity:0.7;font-size:10px;">MIT License ‚Äî Free to use & modify</span>
</div>

</body>
</html>