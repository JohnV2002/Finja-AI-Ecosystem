<!-- ====================================================================== -->
<!--                      Finja's Twitch Bot & Overlay                      -->
<!-- ====================================================================== -->
<!--                                                                        -->
<!--   Project: Finja - Twitch Interactivity Suite                          -->
<!--   Author: J. Apps (JohnV2002 / Sodakiller1)                            -->
<!--   Version: 2.2.1                                                       -->
<!--   Description: Bot panel and visual overlay for OBS.                   -->
<!--                                                                        -->
<!--   ‚ú® New in 2.2.1:                                                     -->
<!--     ‚Ä¢ Code Quality: All SonarQube issues are resolved                  -->
<!--     ‚Ä¢ Improved error handling with specific and or more error messages -->
<!--     ‚Ä¢ Centralized BroadcastChannel management (no duplicates)          -->
<!--     ‚Ä¢ Complete English code documentation for GitHub                   -->
<!--     ‚Ä¢ Extracted functions for better code organization                 -->
<!--     ‚Ä¢ Constants instead of magic numbers for maintainability           -->
<!--                                                                        -->
<!--   üìú Changelog 2.2.0:                                                  -->
<!--     ‚Ä¢ Finja stays ALWAYS blue (independent of !accent)                 -->
<!--     ‚Ä¢ !uptime command added (shows stream duration)                    -->
<!--     ‚Ä¢ Modular control: VPet Bridge & Song Requests can be disabled     -->
<!--     ‚Ä¢ AI responses (!ask/!chat) stay longer in overlay                 -->
<!--     ‚Ä¢ Improved system prompt with streamer & game context              -->
<!--                                                                        -->
<!--   Copyright (c) 2026 J. Apps                                           -->
<!--   Licensed under the MIT License.                                      -->
<!-- ====================================================================== -->

<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Finja Bot Panel</title>

  <script src="https://cdn.jsdelivr.net/npm/comfy.js@1.1.1/dist/comfy.min.js  "></script>
  <script src="https://cdn.jsdelivr.net/npm/obs-websocket-js@5/dist/obs-ws.min.js  "></script>

  <style>
    :root{ --accent:#7aa2ff }
    *{ box-sizing: border-box }
    body{
      margin:0; padding:0;
      font:15px/1.4 Inter, system-ui, Arial;
      background:#0c0e14; color:#f0f4fa;
    }
    h2{ margin:16px 16px 0; color:var(--accent) }
    .card{ background:#121725; border:1px solid #263048; border-radius:12px; padding:14px; margin:16px }
    .row{ display:grid; grid-template-columns:1fr 1fr; gap:10px }
    label{ display:block; font-size:12px; color:#c5d1e8; margin-top:8px }
    input, textarea{ width:100%; padding:8px 10px; border-radius:10px; border:1px solid #364057; background:#0b0f1a; color:#eaf1ff; font:inherit }
    textarea{ min-height: 80px; resize: vertical; }
    .btn{ display:inline-block; margin-top:10px; padding:10px 12px; border-radius:10px; background:#1a5cff; color:#ffffff; border:0; cursor:pointer }
    .btn.alt{ background:#555; color:#eee; }
    #log{ font-size:14px; line-height:1.4; padding:10px; max-height:320px; overflow:auto; white-space:pre-wrap; background:#0b0f1a; border:1px solid #2b3447; border-radius:10px; color:#d0d8e8; }
    #log .ok{ color:#7df97d } #log .warn{ color:#ffd166 } #log .err{ color:#ff6b6b }
    code{ background:#0b0f1a; padding:2px 6px; border-radius:6px; border:1px solid #2b3447; color:#c5d1e8; }

    /* Pretty Commands Panel */
    .cmds {
      margin: 16px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 12px;
      padding: 12px 14px;
      color: #6e6e6e;
      font: 14px/1.4 Inter, system-ui, Arial;
    }
    .cmds .title {
      font-weight: 700; color: var(--accent,#7aa2ff); margin-bottom: 8px;
      display:flex; align-items:center; gap:8px;
    }
    .cmds .list { display: grid; gap: 8px 16px; grid-template-columns: 1fr 1fr; }
    .cmds .item { display:flex; gap:8px; align-items:flex-start; }
    .cmds .k {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.08);
      padding: 2px 6px; border-radius: 8px; white-space: nowrap;
      color: #e0e8f0;
    }
    .cmds .desc { color: #d0d8e8; }
    .cmds .note {
      margin-top: 10px; color: #b8c4d8; font-size: 13px;
      border-top: 1px dashed rgba(255,255,255,.12); padding-top: 10px;
    }
    .cmds .subgrid { display:grid; gap:6px }
    @media (max-width: 900px) { .cmds .list { grid-template-columns: 1fr; } }
  </style>
</head>
<body>

  <h2>Finja Bot Panel</h2>

  <div class="card">
    <div class="row">
      <div>
        <label for="channel">Channel</label>
        <input id="channel" placeholder="yourchannel" value="sodakiller1">
      </div>
      <div>
        <label for="botuser">Bot Username</label>
        <input id="botuser" placeholder="finja_chat_bot" value="finja_chat_bot">
      </div>
    </div>
    <label for="oauth">OAuth (Format: <code>oauth:xxxxxxxxxxxxxxxx</code>)</label>
    <input id="oauth" placeholder="oauth:..." type="password" />
    <button class="btn" id="connectBtn">Connect</button>
    <button class="btn alt" id="disconnectBtn">Disconnect</button>
  </div>

  <div class="cmds">
    <div class="title">üß≠ Commands</div>
    <div class="list">
      <div class="item"><div class="k">!ask | !chat</div><div class="desc">Ask the AI a question ü§ñ</div></div>
      <div class="item"><div class="k">!help</div><div class="desc">Overview (also shows overlay panel)</div></div>
      <div class="item"><div class="k">!drink</div><div class="desc">Give Finja something to drink ü•§</div></div>
      <div class="item"><div class="k">!uptime</div><div class="desc">Shows stream duration ‚è±Ô∏è</div></div>
      <div class="item"><div class="k">!theme</div><div class="desc">glass | dark | light | neon (neon auto-enables <span class="k">rgb ring</span>)</div></div>
      <div class="item"><div class="k">!rgb</div><div class="desc">off | ring | fill | both ¬∑ <span class="k">!rgb ring <6-10></span></div></div>
      <div class="item"><div class="k">!rgbspeed</div><div class="desc">2-30 (seconds)</div></div>
      <div class="item"><div class="k">!ring</div><div class="k">6-10 (ring width)</div></div>
      <div class="item"><div class="k">!opacity</div><div class="desc">0-100</div></div>
      <div class="item"><div class="k">!pulse</div><div class="desc">on | off</div></div>
      <div class="item"><div class="k">!accent</div><div class="desc">finja | channel | custom #hex</div></div>
    </div>

    <div class="title" style="margin-top:12px">üéµ Song Requests</div>
    <div class="subgrid">
      <div class="item"><div class="k">!sr</div><div class="desc">Viewer: <search|link> (Spotify)</div></div>
      <div class="item"><div class="k">!rq</div><div class="desc">Mods: List requests</div></div>
      <div class="item"><div class="k">!accept</div><div class="desc">Mods: <id> to queue</div></div>
      <div class="item"><div class="k">!deny</div><div class="desc">Mods: <id> deny</div></div>
    </div>
    <div class="note">
      Cooldown: 60s global + 60s/User (does <b>not</b> apply to <span class="k">!drink</span> and <span class="k">!ask</span>).
      <span class="k">Usage</span> does not consume cooldown.
    </div>
  </div>

  <div class="card">
    <h2 style="margin:0 0 8px 0;color:#7aa2ff">ü§ñ LLM Chatbot (OpenWebUI)</h2>
    <label for="llm_enabled" style="display:flex; align-items:center; gap:8px;">
      <input id="llm_enabled" type="checkbox" style="width:auto;"> Enable LLM Chatbot
    </label>

    <div class="row">
        <div>
            <label for="llm_url">OpenWebUI URL</label>
            <input id="llm_url" placeholder="http://localhost:3000">
        </div>
        <div>
            <label for="llm_model">Model ID</label>
            <input id="llm_model" placeholder="llama3:latest">
        </div>
    </div>
    <label for="llm_key">OpenWebUI API Key</label>
    <input id="llm_key" type="password" placeholder="Your API Key...">

    <label for="llm_system_prompt">System Prompt (AI Instructions)</label>
    <textarea id="llm_system_prompt">You are Finja, a cheerful and helpful cat and the streamer of a Twitch channel. Answer briefly, friendly, and directly to user messages in chat. Always address users by their name.</textarea>

    <button class="btn" id="llm_save_settings">Save Settings</button>
    <button class="btn alt" id="llm_clear_history">Clear Chat Memory</button>
  </div>

  <div class="card">
    <h2 style="margin:0 0 8px 0;color:#7aa2ff">OBS Sync</h2>
    <div class="row">
      <div>
        <label for="obs_addr">OBS WS Address</label>
        <input id="obs_addr" placeholder="ws://127.0.0.1:4455" value="ws://127.0.0.1:4455">
      </div>
      <div>
        <label for="obs_pass">OBS Password</label>
        <input id="obs_pass" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" type="password">
      </div>
    </div>
    <div class="row">
      <div>
        <label for="obs_input">Browser Source (Name in OBS)</label>
        <input id="obs_input" placeholder="Finja Overlay">
      </div>
      <div>
        <label for="obs_overlay_url">Overlay URL (Base)</label>
        <input id="obs_overlay_url" placeholder="http://127.0.0.1:8088/index_merged.html">
        <small>The bot automatically appends parameters (channel, theme, ‚Ä¶).</small>
      </div>
    </div>
    <button class="btn" id="obs_connect">Connect OBS</button>
    <button class="btn alt" id="obs_disconnect">Disconnect OBS</button>
  </div>

  <div class="card">
    <h2 style="margin:0 0 8px 0;color:#7aa2ff">üéÆ VPet Bridge & Song Requests</h2>
    <label for="vpet_enabled" style="display:flex; align-items:center; gap:8px;">
      <input id="vpet_enabled" type="checkbox" style="width:auto;" checked> Enable VPet Bridge
    </label>
    <label for="sr_enabled" style="display:flex; align-items:center; gap:8px;">
      <input id="sr_enabled" type="checkbox" style="width:auto;" checked> Enable Song Requests
    </label>
    <button class="btn" id="save_settings">Save Settings</button>
  </div>

  <div class="card">
    <h2 style="margin:0 0 8px 0;color:#7aa2ff">üìú Log</h2>
    <div id="log"></div>
  </div>

  <!-- Attribution Footer -->
  <div style="text-align:center;padding:20px;margin-top:10px;opacity:0.6;font-size:12px;color:#eaf1ff;">
    Made with ‚ù§Ô∏è by <a href="https://twitch.tv/sodakiller1" target="_blank" style="color:#7aa2ff;text-decoration:none;font-weight:600;">Sodakiller1</a> 
    (J. Apps / JohnV2002)
    <br>
    <span style="opacity:0.7;font-size:11px;">Open source under MIT License ‚Äî Free to use, modify, and monetize. Attribution appreciated!</span>
  </div>
</div>

<script>
"use strict";

/* ========== Constants ========== */
// Cooldown duration for commands in milliseconds (60 seconds)
const COOLDOWN_MS = 60000;

// Duration to display LLM responses in the overlay (15 seconds)
const LLM_DISPLAY_DURATION_MS = 15000;

// Delay before refreshing the OBS browser source (100ms)
const OVERLAY_REFRESH_DELAY_MS = 100;

// Maximum number of chat messages to keep in LLM conversation history
const MAX_CHAT_HISTORY = 20;

// Delay for theme synchronization to ensure proper rendering (50ms)
const THEME_SYNC_DELAY_MS = 50;

/* ========== Global BroadcastChannel Management ========== */
/**
 * Shared BroadcastChannel instance for cross-tab/window communication
 * Used to communicate between bot panel and overlay
 */
let globalBroadcastChannel = null;

/**
 * Gets or creates a shared BroadcastChannel instance
 * @returns {BroadcastChannel|null} The BroadcastChannel instance or null if not supported
 */
function getOrCreateBroadcastChannel() {
  if (globalBroadcastChannel) {
    return globalBroadcastChannel;
  }
  
  try {
    globalBroadcastChannel = new BroadcastChannel("finja-overlay");
    return globalBroadcastChannel;
  } catch (error) {
    console.error("Failed to create BroadcastChannel:", error);
    return null;
  }
}

/* ========== Helper Functions ========== */
/**
 * Shorthand for document.getElementById
 * @param {string} id - The element ID
 * @returns {HTMLElement|null} The DOM element
 */
const $ = (id) => document.getElementById(id);

/**
 * Logs a message to the UI log panel with optional styling
 * @param {string} msg - The message to log
 * @param {string} cls - Optional CSS class for styling (ok, warn, err)
 */
function log(msg, cls = "") {
  const line = document.createElement("div");
  if (cls) {
    line.className = cls;
  }
  line.textContent = `[${new Date().toLocaleTimeString("de-DE")}] ${msg}`;
  $("log").appendChild(line);
  $("log").scrollTop = $("log").scrollHeight;
}

/* ========== State Management ========== */
/**
 * Global overlay state object containing all visual configuration
 * This state is synchronized with the OBS browser source overlay
 */
const OVERLAY = {
  channel: "",              // Twitch channel name
  botname: "finja_chat_bot", // Bot username
  theme: "glass",           // Visual theme: glass, dark, light, neon
  rgb: "off",               // RGB mode: off, ring, fill, both
  rgbspeed: 15,             // RGB animation speed in seconds (2-30)
  ring: 8,                  // Ring width in pixels (6-10)
  opacity: 100,             // Overlay opacity (0-100)
  pulse: false,             // Pulse animation enabled
  accent: "finja",          // Accent color mode: finja, channel, custom
  accentHex: ""             // Custom accent color hex value
};

// Connection state flag
let connected = false;

// Command cooldown tracker: Map<"user:command", timestamp>
const lastCmd = new Map();

// LLM conversation history for context retention
const chatHistory = [];

/* ========== OBS WebSocket ========== */
/**
 * OBS WebSocket instance for controlling OBS Studio
 * Requires obs-websocket-js library
 */
let obs = null;

// OBS connection state (if obs-websocket-js is loaded and connected)
let obsConnected = false;

/**
 * Connect to OBS WebSocket server
 * Handles connection with authentication and provides detailed error messages
 */
$("obs_connect").onclick = async () => {
  const addr = $("obs_addr").value.trim() || "ws://127.0.0.1:4455";
  const pass = $("obs_pass").value.trim();
  
  if (typeof OBSWebSocket === "undefined") {
    log("‚ùå OBS WebSocket library not loaded.", "err");
    return;
  }
  
  try {
    obs = new OBSWebSocket.default();
    await obs.connect(addr, pass);
    obsConnected = true;
    log("‚úÖ OBS connected.", "ok");
  } catch (error) {
    obsConnected = false;
    
    if (error.code === "CONNECTION_ERROR") {
      log(`‚ùå OBS not reachable. Is OBS running and WebSocket enabled?`, "err");
    } else if (error.code === "AUTHENTICATION_FAILED") {
      log(`‚ùå OBS password incorrect.`, "err");
    } else {
      log(`‚ùå OBS connection failed: ${error.message || error}`, "err");
    }
    
    console.error("OBS connection failed:", error);
  }
};

/**
 * Disconnect from OBS WebSocket server
 * Validates connection state before attempting disconnect
 */
$("obs_disconnect").onclick = async () => {
  if (!obs) {
    log("‚ö†Ô∏è No OBS connection active.", "warn");
    return;
  }
  
  if (!obsConnected) {
    log("‚ö†Ô∏è OBS already disconnected.", "warn");
    return;
  }
  
  try {
    await obs.disconnect();
    obsConnected = false;
    log("OBS disconnected.", "warn");
  } catch (error) {
    log(`‚ö†Ô∏è OBS disconnect error: ${error.message || error}`, "err");
    console.error("OBS disconnect failed:", error);
  }
};

/* ========== Overlay URL Builder ========== */
/**
 * Builds the complete overlay URL with all current state parameters
 * The overlay (index_merged.html) reads these URL parameters to configure itself
 * @returns {string} Complete URL with query parameters
 */
function buildOverlayURL() {
  const base = $("obs_overlay_url").value.trim() || "http://127.0.0.1:8088/index_merged.html";
  const params = new URLSearchParams({
    channel: OVERLAY.channel || "",
    theme: OVERLAY.theme || "glass",
    rgb: OVERLAY.rgb || "off",
    rgbspeed: String(OVERLAY.rgbspeed || 15),
    ring: String(OVERLAY.ring || 8),
    opacity: String(OVERLAY.opacity || 100),
    pulse: OVERLAY.pulse ? "on" : "off",
    accent: OVERLAY.accent || "finja",
    accentHex: OVERLAY.accentHex || ""
  });
  return `${base}?${params.toString()}`;
}

/**
 * Refreshes the OBS browser source with updated overlay URL
 * This propagates visual changes from bot panel to the OBS overlay
 * Requires active OBS connection and valid browser source name
 */
async function refreshBrowserSource() {
  if (!obs) {
    console.warn("refreshBrowserSource: OBS instance not available");
    return;
  }
  
  if (!obsConnected) {
    console.warn("refreshBrowserSource: OBS not connected");
    return;
  }

  const inputName = $("obs_input").value.trim() || "Finja Overlay";
  const newURL = buildOverlayURL();

  try {
    await obs.call("SetInputSettings", {
      inputName: inputName,
      inputSettings: { url: newURL }
    });
    log(`üîÑ Overlay updated: ${newURL}`, "ok");
  } catch (error) {
    if (error.code === "RESOURCE_NOT_FOUND") {
      log(`‚ùå Browser source "${inputName}" not found in OBS.`, "err");
    } else {
      log(`‚ùå Overlay update error: ${error.message || error}`, "err");
    }
    console.error("refreshBrowserSource failed:", error);
  }
}

/* ========== Cooldown Management ========== */
/**
 * Checks if a user is on cooldown for a specific command
 * Global cooldown prevents command spam (60 seconds per user per command)
 * @param {string} user - Username
 * @param {string} cmd - Command name
 * @returns {boolean} True if user is on cooldown
 */
function onCooldown(user, cmd) {
  const key = `${user}:${cmd}`;
  const now = Date.now();
  const last = lastCmd.get(key) || 0;
  
  if (now - last < COOLDOWN_MS) {
    return true;
  }
  
  lastCmd.set(key, now);
  return false;
}

/* ========== Visual Command Helpers ========== */
/**
 * Updates overlay state and triggers OBS browser source refresh
 * @param {string} key - State property to update
 * @param {any} value - New value for the property
 */
function updateOverlayState(key, value) {
  OVERLAY[key] = value;
  setTimeout(refreshBrowserSource, OVERLAY_REFRESH_DELAY_MS);
}

/**
 * Parses RGB command arguments
 * Format: "mode [ringWidth]" e.g., "ring 8"
 * @param {string} arg - Command argument string
 * @returns {{mode: string, ringWidth: number|null}} Parsed RGB settings
 */
function parseRGBCommand(arg) {
  const parts = arg.toLowerCase().trim().split(/\s+/);
  const mode = parts[0] || "off";
  const ringWidth = parts[1] ? Number.parseInt(parts[1], 10) : null;
  
  return { mode, ringWidth };
}

/**
 * Parses accent command arguments
 * Format: "mode [hex]" e.g., "custom #ff00ff"
 * @param {string} arg - Command argument string
 * @returns {{mode: string, hex: string}} Parsed accent settings
 */
function parseAccentCommand(arg) {
  const parts = arg.toLowerCase().trim().split(/\s+/);
  const mode = parts[0] || "finja";
  const hex = parts[1] || "";
  
  return { mode, hex };
}

/**
 * Handles !theme command
 * Valid themes: glass, dark, light, neon
 * @param {string} arg - Theme name
 */
function handleThemeCommand(arg) {
  if (["glass", "dark", "light", "neon"].includes(arg)) {
    updateOverlayState("theme", arg);
  }
}

/**
 * Handles !rgb command
 * Sets RGB lighting mode and optionally ring width
 * Valid modes: off, ring, fill, both
 * Ring width: 6-10 pixels
 * @param {string} arg - RGB command arguments
 */
function handleRGBCommand(arg) {
  const { mode, ringWidth } = parseRGBCommand(arg);
  if (["off", "ring", "fill", "both"].includes(mode)) {
    updateOverlayState("rgb", mode);
    if (ringWidth !== null && ringWidth >= 6 && ringWidth <= 10) {
      updateOverlayState("ring", ringWidth);
    }
  }
}

/**
 * Handles !rgbspeed command
 * Sets RGB animation speed in seconds (2-30)
 * @param {string} arg - Speed value
 */
function handleRGBSpeedCommand(arg) {
  const speed = Number.parseInt(arg, 10);
  if (speed >= 2 && speed <= 30) {
    updateOverlayState("rgbspeed", speed);
  }
}

/**
 * Handles !ring command
 * Sets ring width in pixels (6-10)
 * @param {string} arg - Ring width value
 */
function handleRingCommand(arg) {
  const width = Number.parseInt(arg, 10);
  if (width >= 6 && width <= 10) {
    updateOverlayState("ring", width);
  }
}

/**
 * Handles !opacity command
 * Sets overlay opacity (0-100)
 * @param {string} arg - Opacity value
 */
function handleOpacityCommand(arg) {
  const val = Number.parseInt(arg, 10);
  if (val >= 0 && val <= 100) {
    updateOverlayState("opacity", val);
  }
}

/**
 * Handles !pulse command
 * Enables/disables pulse animation
 * Valid values: on, off
 * @param {string} arg - Pulse state
 */
function handlePulseCommand(arg) {
  if (arg === "on" || arg === "off") {
    updateOverlayState("pulse", arg === "on");
  }
}

/**
 * Handles !accent command
 * Sets accent color mode
 * Modes: finja (default blue), channel (uses Twitch channel color), custom #hex
 * @param {string} arg - Accent command arguments
 */
function handleAccentCommand(arg) {
  const { mode, hex } = parseAccentCommand(arg);
  if (["finja", "channel"].includes(mode)) {
    OVERLAY.accent = mode;
    OVERLAY.accentHex = "";
    setTimeout(refreshBrowserSource, OVERLAY_REFRESH_DELAY_MS);
  } else if (mode === "custom" && hex.match(/^#[0-9a-f]{6}$/i)) {
    OVERLAY.accent = "custom";
    OVERLAY.accentHex = hex;
    setTimeout(refreshBrowserSource, OVERLAY_REFRESH_DELAY_MS);
  }
}

/**
 * Main dispatcher for visual commands
 * Routes command to appropriate handler based on command type
 * @param {string} cmd - Command name
 * @param {string} arg - Command arguments
 * @param {object} flags - User flags (mod, broadcaster, etc.)
 */
function sendVisual(cmd, arg, flags) {
  const lowCmd = cmd.toLowerCase();
  const lowArg = String(arg || "").toLowerCase().trim();

  switch (lowCmd) {
    case "theme":
      handleThemeCommand(lowArg);
      break;
    case "rgb":
      handleRGBCommand(lowArg);
      break;
    case "rgbspeed":
      handleRGBSpeedCommand(lowArg);
      break;
    case "ring":
      handleRingCommand(lowArg);
      break;
    case "opacity":
      handleOpacityCommand(lowArg);
      break;
    case "pulse":
      handlePulseCommand(lowArg);
      break;
    case "accent":
      handleAccentCommand(lowArg);
      break;
    default:
      break;
  }
}

/* ========== LLM Integration ========== */
/**
 * Retrieves current LLM configuration from UI inputs
 * @returns {{enabled: boolean, url: string, model: string, key: string, systemPrompt: string}}
 */
function getLLMConfig() {
  return {
    enabled: $("llm_enabled").checked,
    url: $("llm_url").value.trim(),
    model: $("llm_model").value.trim(),
    key: $("llm_key").value.trim(),
    systemPrompt: $("llm_system_prompt").value.trim()
  };
}

/**
 * Saves LLM settings to localStorage for persistence
 */
function saveLLMSettings() {
  const cfg = getLLMConfig();
  localStorage.setItem("finja_llm_enabled", cfg.enabled);
  localStorage.setItem("finja_llm_url", cfg.url);
  localStorage.setItem("finja_llm_model", cfg.model);
  localStorage.setItem("finja_llm_key", cfg.key);
  localStorage.setItem("finja_llm_system_prompt", cfg.systemPrompt);
}

/**
 * Loads LLM settings from localStorage and populates UI inputs
 * Called on page load to restore previous configuration
 */
function loadLLMSettings() {
  $("llm_enabled").checked = localStorage.getItem("finja_llm_enabled") === "true";
  $("llm_url").value = localStorage.getItem("finja_llm_url") || "";
  $("llm_model").value = localStorage.getItem("finja_llm_model") || "";
  $("llm_key").value = localStorage.getItem("finja_llm_key") || "";
  $("llm_system_prompt").value = localStorage.getItem("finja_llm_system_prompt") || 
    "You are Finja, a cheerful and helpful cat and the streamer of a Twitch channel. Answer briefly, friendly, and directly to user messages in chat. Always address users by their name.";
}

/**
 * Calls OpenWebUI LLM API to generate a response
 * Maintains conversation history for context-aware responses
 * 
 * @param {string} userMessage - The user's question/message
 * @param {string} userName - The user's Twitch username
 * @returns {Promise<string|null>} LLM response or null on error
 * 
 * Error handling:
 * - 401: Invalid API key
 * - 404: OpenWebUI endpoint not found
 * - 500: OpenWebUI server error
 * - Network errors: Connection issues
 */
async function callLLM(userMessage, userName) {
  const cfg = getLLMConfig();
  
  if (!cfg.enabled) {
    console.warn("LLM is disabled");
    return null;
  }
  
  if (!cfg.url || !cfg.model || !cfg.key) {
    log("‚ö†Ô∏è LLM not configured. Please check settings.", "warn");
    return null;
  }

  chatHistory.push({ role: "user", content: `${userName}: ${userMessage}` });
  if (chatHistory.length > MAX_CHAT_HISTORY) {
    chatHistory.shift();
  }

  const messages = [
    { role: "system", content: cfg.systemPrompt },
    ...chatHistory
  ];

  try {
    const response = await fetch(`${cfg.url}/api/chat/completions`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${cfg.key}`
      },
      body: JSON.stringify({
        model: cfg.model,
        messages: messages,
        stream: false
      })
    });

    if (!response.ok) {
      if (response.status === 401) {
        throw new Error("Invalid API key");
      } else if (response.status === 404) {
        throw new Error("OpenWebUI endpoint not found");
      } else if (response.status === 500) {
        throw new Error("OpenWebUI server error");
      } else {
        throw new Error(`HTTP ${response.status}`);
      }
    }

    const data = await response.json();
    const answer = data?.choices?.[0]?.message?.content || "";
    
    if (answer) {
      chatHistory.push({ role: "assistant", content: answer });
      if (chatHistory.length > MAX_CHAT_HISTORY) {
        chatHistory.shift();
      }
    } else {
      log("‚ö†Ô∏è LLM returned no response.", "warn");
    }
    
    return answer;
  } catch (error) {
    log(`‚ùå LLM error: ${error.message || error}`, "err");
    console.error("callLLM failed:", error);
    return null;
  }
}

$("llm_save_settings").onclick = () => {
  saveLLMSettings();
  log("LLM settings saved.", "ok");
};

$("llm_clear_history").onclick = () => {
  chatHistory.length = 0;
  log("Chat memory cleared.", "warn");
};

/* ========== VPet Bridge ========== */
/**
 * Checks if VPet Bridge is enabled
 * VPet Bridge allows triggering VPet Desktop Pet actions from chat commands
 * @returns {boolean} True if enabled
 */
const vpetEnabled = () => localStorage.getItem("finja_vpet_enabled") !== "false";

/**
 * Sends an action to VPet Desktop Pet via HTTP API
 * Requires VPet Desktop Pet with API server running on localhost:7878
 * 
 * @param {string} action - Action to trigger (e.g., "drink", "eat", "play")
 */
async function sendToVPet(action) {
  if (!vpetEnabled()) {
    return;
  }

  try {
    const response = await fetch("http://127.0.0.1:7878/api/action", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ action })
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const data = await response.json();
    log(`VPet: ${data.message || "OK"}`, "ok");
  } catch (error) {
    log(`VPet error: ${error.message || error}`, "err");
  }
}

/* ========== Stream Uptime ========== */
/**
 * Timestamp when the stream started (set on bot connection)
 * Used to calculate !uptime command response
 */
let streamStartTime = null;

/**
 * Starts the stream uptime timer
 * Called when bot successfully connects to Twitch chat
 */
function startStreamTimer() {
  streamStartTime = Date.now();
  log("‚è±Ô∏è Stream timer started.", "ok");
}

/**
 * Calculates and formats the current stream uptime
 * @returns {string} Formatted uptime string (e.g., "2h 45m 30s") or offline message
 */
function getUptime() {
  if (!streamStartTime) {
    return "Stream is offline or timer was not started.";
  }

  const elapsed = Date.now() - streamStartTime;
  const hours = Math.floor(elapsed / 3600000);
  const minutes = Math.floor((elapsed % 3600000) / 60000);
  const seconds = Math.floor((elapsed % 60000) / 1000);

  return `‚è±Ô∏è Stream l√§uft seit ${hours}h ${minutes}m ${seconds}s`;
}

/* ========== Command Handlers ========== */
/**
 * Sends a cooldown message to chat
 * Extracted to avoid code duplication
 * @param {string} user - Username to notify
 */
function sendCooldownMessage(user) {
  try {
    ComfyJS.Say(`@${user} Cooldown! Wait 60s.`);
  } catch (error) {
    log(`Say error: ${error.message || error}`, "err");
    console.error("sendCooldownMessage failed:", error);
  }
}

/**
 * Handles !help command
 * Only mods/broadcaster see a response to avoid spam
 * @param {string} user - Username
 * @param {object} flags - User flags
 */
function handleHelpCommand(user, flags) {
  const isMod = flags && (flags.mod || flags.broadcaster);
  
  if (isMod) {
    try {
      ComfyJS.Say("üìñ All commands can be found in the panel! (thx for your interest!)");
    } catch (error) {
      log(`Say error: ${error.message || error}`, "err");
    }
  }
}

/**
 * Handles !drink command
 * Triggers VPet drink action and announces in chat
 * No cooldown for this command to allow frequent interaction
 * @param {string} user - Username
 * @param {object} flags - User flags
 */
function handleDrinkCommand(user, flags) {
  sendToVPet("drink");
  
  try {
    ComfyJS.Say(`ü•§ @${user} gives Finja something to drink!`);
  } catch (error) {
    log(`Say error: ${error.message || error}`, "err");
  }
}

/**
 * Handles !ask and !chat commands
 * Sends user question to LLM and displays response in chat and overlay
 * No cooldown to allow natural conversation flow
 * 
 * @param {string} user - Username
 * @param {string} arg - The question/message
 * @param {object} flags - User flags
 * @param {object} extra - Extra user data
 */
async function handleAskCommand(user, arg, flags, extra) {
  const question = arg.trim();
  
  if (!question) {
    try {
      ComfyJS.Say(`@${user} You need to ask a question! (!ask <your question>)`);
    } catch (error) {
      log(`Say error: ${error.message || error}`, "err");
      console.error("handleAskCommand Say failed:", error);
    }
    return;
  }

  const answer = await callLLM(question, user);
  
  if (answer) {
    const bc = getOrCreateBroadcastChannel();
    if (bc) {
      try {
        bc.postMessage({
          type: "llm-response",
          user: user,
          question: question,
          answer: answer,
          duration: LLM_DISPLAY_DURATION_MS
        });
      } catch (error) {
        log(`BroadcastChannel error: ${error.message || error}`, "err");
        console.error("handleAskCommand BroadcastChannel failed:", error);
      }
    }

    try {
      ComfyJS.Say(`ü§ñ Finja: ${answer}`);
    } catch (error) {
      log(`Say error: ${error.message || error}`, "err");
      console.error("handleAskCommand Say failed:", error);
    }
  } else {
    try {
      ComfyJS.Say(`@${user} Sorry, I can't answer right now. üòø`);
    } catch (error) {
      log(`Say error: ${error.message || error}`, "err");
      console.error("handleAskCommand Say failed:", error);
    }
  }
}

/**
 * Handles !uptime command
 * Displays how long the stream has been running
 * @param {string} user - Username
 * @param {object} flags - User flags
 */
function handleUptimeCommand(user, flags) {
  const uptime = getUptime();
  
  try {
    ComfyJS.Say(uptime);
  } catch (error) {
    log(`Say error: ${error.message || error}`, "err");
  }
}

/**
 * Handles visual overlay commands (!theme, !rgb, !opacity, etc.)
 * Enforces 60-second cooldown per user per command
 * Updates overlay state and announces change in chat
 * 
 * @param {string} cmd - Command name
 * @param {string} arg - Command arguments
 * @param {string} user - Username
 * @param {object} flags - User flags
 */
function handleVisualCommand(cmd, arg, user, flags) {
  if (onCooldown(user, cmd)) {
    sendCooldownMessage(user);
    return;
  }

  sendVisual(cmd, arg, flags);
  
  try {
    ComfyJS.Say(`‚úÖ @${user} changed ${cmd}!`);
  } catch (error) {
    log(`Say error: ${error.message || error}`, "err");
    console.error("handleVisualCommand Say failed:", error);
  }
}

/**
 * Main command dispatcher
 * Routes incoming chat commands to appropriate handlers
 * 
 * Supported commands:
 * - !help: Show command list
 * - !drink: Give Finja a drink (VPet action)
 * - !ask / !chat: Ask LLM a question
 * - !uptime: Show stream duration
 * - !theme, !rgb, !rgbspeed, !ring, !opacity, !pulse, !accent: Visual commands
 * 
 * @param {string} user - Username
 * @param {string} cmd - Command name (without !)
 * @param {string} arg - Command arguments
 * @param {object} flags - User flags (mod, broadcaster, subscriber, etc.)
 * @param {object} extra - Additional user data
 */
function handleCommand(user, cmd, arg, flags, extra) {
  const lowCmd = cmd.toLowerCase();

  switch (lowCmd) {
    case "help":
      handleHelpCommand(user, flags);
      break;

    case "drink":
      handleDrinkCommand(user, flags);
      break;

    case "ask":
    case "chat":
      handleAskCommand(user, arg, flags, extra);
      break;

    case "uptime":
      handleUptimeCommand(user, flags);
      break;

    case "theme":
    case "rgb":
    case "rgbspeed":
    case "ring":
    case "opacity":
    case "pulse":
    case "accent":
      handleVisualCommand(lowCmd, arg, user, flags);
      break;

    default:
      break;
  }
}

/* ========== ComfyJS Event Handlers ========== */
/**
 * Fired when ComfyJS successfully connects to Twitch chat
 * Starts the stream uptime timer
 */
ComfyJS.onConnected = (addr, port, isFirstConnect) => {
  connected = true;
  log(`‚úÖ Connected to ${addr}:${port}`, "ok");
  startStreamTimer();
};

/**
 * Fired when a chat command is detected (message starting with !)
 * @param {string} user - Username
 * @param {string} command - Command name (without !)
 * @param {string} message - Command arguments
 * @param {object} flags - User flags
 * @param {object} extra - Additional user data
 */
ComfyJS.onCommand = (user, command, message, flags, extra) => {
  handleCommand(user, command, message, flags, extra);
};

/**
 * Fired for every chat message
 * Provides fallback command detection if onCommand doesn't fire
 * @param {string} user - Username
 * @param {string} message - Full message text
 * @param {object} flags - User flags
 * @param {boolean} self - True if message is from bot itself
 * @param {object} extra - Additional user data
 */
ComfyJS.onChat = (user, message, flags, self, extra) => {
  if (self) {
    return;
  }

  const trimmed = message.trim();
  if (!trimmed.startsWith("!")) {
    return;
  }

  const parts = trimmed.split(/\s+/);
  const cmd = parts[0].slice(1);
  const arg = parts.slice(1).join(" ");

  handleCommand(user, cmd, arg, flags, extra);
};

/* ========== Connection Management ========== */
/**
 * Connect button handler
 * Initializes ComfyJS connection to Twitch chat and refreshes OBS overlay
 */
$("connectBtn").onclick = () => {
  const channel = $("channel").value.trim();
  const botuser = $("botuser").value.trim();
  const oauth = $("oauth").value.trim();

  if (!channel || !botuser || !oauth) {
    log("Please fill in all fields!", "err");
    return;
  }

  try {
    ComfyJS.Init(botuser, oauth, channel);
    localStorage.setItem("finja_last_channel", channel);
    OVERLAY.channel = channel;
    OVERLAY.botname = botuser;

    refreshBrowserSource();
    log(`Connecting as @${botuser} to #${channel} ...`, "ok");
  } catch (error) {
    log(`Init error: ${error.message || error}`, "err");
  }
};

/**
 * Disconnect button handler
 * Cleanly disconnects from Twitch chat
 */
$("disconnectBtn").onclick = () => {
  try {
    if (typeof ComfyJS.Disconnect === "function") {
      ComfyJS.Disconnect();
    }
    connected = false;
    log("Disconnected.", "warn");
  } catch (error) {
    log(`Disconnect error: ${error.message || error}`, "err");
  }
};

/* ========== Settings Management ========== */
/**
 * Load settings from localStorage on page load
 * Restores VPet Bridge, Song Requests, and LLM settings
 */
document.addEventListener("DOMContentLoaded", function() {
  loadLLMSettings();
  
  $("vpet_enabled").checked = localStorage.getItem("finja_vpet_enabled") !== "false";
  $("sr_enabled").checked = localStorage.getItem("finja_sr_enabled") !== "false";
});

/**
 * Save VPet Bridge and Song Requests toggle states
 */
$("save_settings").onclick = function() {
  localStorage.setItem("finja_vpet_enabled", $("vpet_enabled").checked);
  localStorage.setItem("finja_sr_enabled", $("sr_enabled").checked);
  log("Settings saved.", "ok");
};

/**
 * Checks if Song Requests module is enabled
 * @returns {boolean} True if enabled
 */
const srEnabled = () => localStorage.getItem("finja_sr_enabled") !== "false";
</script>

<script>
/**
 * ========================================================================
 * Song Requests Module
 * ========================================================================
 * 
 * Handles Spotify song requests from viewers via chat commands.
 * Communicates with external SR server running on localhost:8099.
 * 
 * Commands:
 * - !sr <search|link>: Request a song (viewers)
 * - !rq: List pending requests (mods)
 * - !accept <id>: Accept a request (mods)
 * - !deny <id>: Deny a request (mods)
 * 
 * Features:
 * - Client-side cooldown (default 120s, configurable via ?srcd=<seconds>)
 * - Mods/broadcaster bypass cooldown
 * - Can be disabled via settings panel
 */
(() => {
  // Server endpoint for song request management
  const SR_ENDPOINT = "http://127.0.0.1:8099/chat";
  
  // All commands handled by this module
  const SR_ALIASES = new Set(["sr","songrequest","queue","q","accept","deny","rq","requests","pending"]);
  
  // Commands that trigger cooldown (user requests)
  const SR_REQUEST_CMDS = new Set(["sr","songrequest","queue","q"]);

  // Exit early if Song Requests module is disabled
  if (!srEnabled()) {
    return;
  }

  // Parse cooldown from URL parameter (default: 120 seconds)
  const qs = new URLSearchParams(globalThis.location.search || "");
  const LOCAL_CD_MS = Math.max(0, (Number.parseInt(qs.get("srcd") || "120", 10) || 120) * 1000);
  
  // Cooldown tracker: Map<username, timestamp>
  const lastByUser = new Map();

  /**
   * Checks if a user is on cooldown for song requests
   * Mods and broadcaster always bypass cooldown
   * @param {string} user - Username
   * @param {object} flags - User flags
   * @returns {boolean} True if user is on cooldown
   */
  function onLocalCooldown(user, flags) {
    if (!LOCAL_CD_MS) {
      return false;
    }
    if (flags && (flags.mod || flags.broadcaster)) {
      return false;
    }
    
    const u = String(user || "").toLowerCase();
    const now = Date.now();
    const t = lastByUser.get(u) || 0;
    
    if (now - t < LOCAL_CD_MS) {
      return true;
    }
    
    lastByUser.set(u, now);
    return false;
  }

  const botname = (globalThis.OVERLAY && globalThis.OVERLAY.botname) || "finja_chat_bot";
  
  /**
   * Gets or creates BroadcastChannel for SR module
   * Tries to use global instance if available
   * @returns {BroadcastChannel|null} BroadcastChannel instance or null
   */
  function getSRBroadcastChannel() {
    if (typeof globalThis.getOrCreateBroadcastChannel === "function") {
      return globalThis.getOrCreateBroadcastChannel();
    }
    
    try {
      return globalThis.bc || new BroadcastChannel("finja-overlay");
    } catch (error) {
      console.warn("BroadcastChannel not available:", error);
      return null;
    }
  }

  /**
   * Sends a message to chat or overlay
   * Tries ComfyJS.Say first, falls back to BroadcastChannel if unavailable
   * @param {string} text - Message to send
   */
  function sayOrOverlay(text) {
    let said = false;
    
    try {
      if (typeof ComfyJS.Say === "function") {
        ComfyJS.Say(text);
        said = true;
      }
    } catch (error) {
      console.warn("ComfyJS.Say failed:", error);
    }
    
    if (!said) {
      const bc = getSRBroadcastChannel();
      if (bc) {
        try {
          bc.postMessage({
            type: "chat",
            user: botname,
            message: text,
            flags: { broadcaster: true },
            extra: { displayName: botname }
          });
        } catch (error) {
          console.warn("BroadcastChannel postMessage failed:", error);
        }
      }
    }
  }

  /**
   * Generates cooldown message text
   * @param {string} user - Username to notify
   * @returns {string} Formatted cooldown message
   */
  function finjaCooldownText(user) {
    const secs = Math.max(1, Math.round(LOCAL_CD_MS / 1000));
    return `üí§ Finja: Take a breather, ${user}! One request every ${secs}s.`;
  }

  /**
   * Handles response from SR server
   * Processes server response and sends appropriate message to chat
   * @param {object} data - Response data from SR server
   */
  function handleSRResponse(data) {
    if (!data) {
      return;
    }

    if (data.finja) {
      handleFinjaResponse(data.finja);
      return;
    }

    if (data.reply) {
      sayOrOverlay(String(data.reply));
    }
  }

  /**
   * Handles Finja-specific response from SR server
   * Tries to send via ComfyJS, falls back to BroadcastChannel
   * @param {string} finjaText - Response text from server
   */
  function handleFinjaResponse(finjaText) {
    try {
      ComfyJS.Say(String(finjaText));
    } catch (error) {
      console.warn("ComfyJS.Say failed:", error);
      sendToBroadcastChannel(finjaText);
    }
  }

  /**
   * Sends SR announcement to BroadcastChannel
   * Used when ComfyJS.Say is unavailable
   * @param {string} text - Text to send
   */
  function sendToBroadcastChannel(text) {
    const bc = getSRBroadcastChannel();
    if (!bc) {
      console.warn("BroadcastChannel not available for SR announce");
      return;
    }

    try {
      bc.postMessage({ type: "sr-announce", text: String(text) });
    } catch (bcError) {
      console.warn("BroadcastChannel postMessage failed:", bcError);
    }
  }

  /**
   * Sends song request command to SR server
   * Constructs payload and handles server communication
   * 
   * @param {string} user - Username
   * @param {string} cmd - Command name
   * @param {string} arg - Command arguments
   * @param {object} flags - User flags
   */
  async function sendToSR(user, cmd, arg, flags) {
    const messageText = arg ? `!${cmd} ${arg}` : `!${cmd}`;
    const payload = {
      user: String(user || ""),
      message: messageText,
      is_mod: !!(flags && (flags.mod || flags.broadcaster)),
      is_broadcaster: !!(flags && flags.broadcaster)
    };

    try {
      const res = await fetch(SR_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      if (!res.ok) {
        throw new Error(`HTTP ${res.status}: ${res.statusText}`);
      }

      const data = await res.json();
      handleSRResponse(data);
    } catch (error) {
      const isNetworkError = error.name === "TypeError" || error.message.includes("fetch");
      
      if (isNetworkError) {
        console.warn("[SR] Server not reachable:", error);
        sayOrOverlay("‚ö†Ô∏è Finja SR: The server is not responding. Is it running?");
      } else {
        console.warn("[SR] Request failed:", error);
        sayOrOverlay("‚ö†Ô∏è Finja SR: Request failed.");
      }
    }
  }

  // Store original ComfyJS.onCommand handler
  const prevOnCommand = ComfyJS.onCommand;
  
  /**
   * Intercepts ComfyJS.onCommand to add SR handling and theme extras
   * Calls original handler first, then processes SR commands
   */
  ComfyJS.onCommand = (user, command, message, flags, extra) => {
    const cmd = String(command || "").toLowerCase();
    const arg = String(message || "");

    // Call original handler first for non-SR commands
    if (typeof prevOnCommand === "function") {
      try {
        prevOnCommand(user, command, message, flags, extra);
      } catch (error) {
        console.error("prevOnCommand error:", error);
      }
    }

    // Theme extras: neon theme auto-enables RGB ring mode
    if (cmd === "theme") {
      setTimeout(() => {
        try {
          if (arg.trim().toLowerCase() === "neon") {
            sendVisual("rgb", "ring", flags);
          }
          const accMode = (globalThis.OVERLAY && globalThis.OVERLAY.accent) || "finja";
          const accHex = (globalThis.OVERLAY && globalThis.OVERLAY.accentHex) || "";
          const accentArg = accMode === "custom" && accHex ? `${accMode} ${accHex}` : accMode;
          sendVisual("accent", accentArg, flags);
        } catch (error) {
          console.warn("theme extras failed", error);
        }
      }, THEME_SYNC_DELAY_MS);
      return;
    }

    // Don't interfere with core commands (handled by main bot)
    if (cmd === "help" || cmd === "ask" || cmd === "chat" || cmd === "uptime") {
      return;
    }

    // Handle SR commands
    if (SR_ALIASES.has(cmd)) {
      if (SR_REQUEST_CMDS.has(cmd) && onLocalCooldown(user, flags)) {
        try {
          sayOrOverlay(finjaCooldownText(user));
        } catch (error) {
          console.warn("sayOrOverlay failed:", error);
        }
        return;
      }
      sendToSR(user, cmd, arg, flags);
    }
  };

  // Store original ComfyJS.onChat handler
  const prevOnChat = ComfyJS.onChat;
  
  /**
   * Intercepts ComfyJS.onChat to catch SR commands if onCommand doesn't fire
   * Provides fallback command detection
   */
  ComfyJS.onChat = (user, message, flags, self, extra) => {
    if (!self && typeof message === "string" && message.trim().startsWith("!")) {
      const parts = message.trim().split(/\s+/);
      const name = parts[0].slice(1).toLowerCase();
      const rest = parts.slice(1).join(" ");
      
      if (SR_ALIASES.has(name)) {
        if (SR_REQUEST_CMDS.has(name) && onLocalCooldown(user, flags)) {
          try {
            sayOrOverlay(finjaCooldownText(user));
          } catch (error) {
            console.warn("sayOrOverlay failed:", error);
          }
          return;
        }
        sendToSR(user, name, rest, flags);
        return;
      }
    }
    
    if (typeof prevOnChat === "function") {
      try {
        prevOnChat(user, message, flags, self, extra);
      } catch (error) {
        console.error("prevOnChat error:", error);
      }
    }
  };
})();
</script>

<script>
/**
 * ========================================================================
 * Song Request Announcement Listener
 * ========================================================================
 * 
 * Listens for SR announcements via BroadcastChannel and outputs to chat.
 * This allows the SR server to communicate back to the bot for chat output.
 */
(function() {
  /**
   * Sets up BroadcastChannel listener for SR announcements
   * Tries to use global instance if available
   */
  function setupSRAnnounceListener() {
    let bc = null;
    
    // Try to use global BroadcastChannel instance
    if (typeof globalThis.getOrCreateBroadcastChannel === "function") {
      bc = globalThis.getOrCreateBroadcastChannel();
    } else {
      // Fallback: create new instance
      try {
        bc = new BroadcastChannel("finja-overlay");
      } catch (error) {
        console.warn("BroadcastChannel not available for SR announce listener:", error);
        return;
      }
    }
    
    if (!bc) {
      console.warn("Failed to create BroadcastChannel for SR announce listener");
      return;
    }
    
    // Listen for SR announcements and output to chat
    bc.onmessage = (ev) => {
      const data = ev.data || {};
      if (data.type === "sr-announce" && data.text) {
        if (typeof ComfyJS.Say === "function") {
          try {
            ComfyJS.Say(data.text);
          } catch (error) {
            console.warn("Say failed in SR announce listener:", error);
          }
        }
      }
    };
  }
  
  setupSRAnnounceListener();
})();
</script>
  <!--
    [[[[[[[[[[[[[[[      ]]]]]]]]]]]]]]]
    [::::::::::::::      ::::::::::::::]
    [::::::::::::::      ::::::::::::::]
    [::::::[[[[[[[:      :]]]]]]]::::::]
    [:::::[                      ]:::::]
    [:::::[                      ]:::::]
    [:::::[                      ]:::::]
    [:::::[        J.Apps        ]:::::]
    [:::::[     CODE THE WEB     ]:::::]
    [:::::[                      ]:::::]
    [:::::[                      ]:::::]
    [:::::[                      ]:::::]
    [:::::[                      ]:::::]
    [:::::[                      ]:::::]
    [::::::[[[[[[[:      :]]]]]]]::::::]
    [::::::::::::::      ::::::::::::::]
    [::::::::::::::      ::::::::::::::]
    [[[[[[[[[[[[[[[      ]]]]]]]]]]]]]]]
  -->
</body>
</html>