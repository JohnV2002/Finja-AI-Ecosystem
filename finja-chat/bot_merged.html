<!-- ====================================================================== -->
<!--                      Finja's Twitch Bot & Overlay                      -->
<!-- ====================================================================== -->
<!--                                                                        -->
<!--   Project: Finja - Twitch Interactivity Suite                          -->
<!--   Author: JohnV2002 (J. Apps / Sodakiller1)                            -->
<!--   Version: 2.2.0                                                       -->
<!--   Description: Bot panel and visual overlay for OBS.                   -->
<!--                                                                        -->
<!--   ‚ú® Neu in 2.2.0:                                                     -->
<!--     ‚Ä¢ Finja bleibt IMMER blau (unabh√§ngig von !accent)                 -->
<!--     ‚Ä¢ !uptime Befehl hinzugef√ºgt (zeigt Stream-Dauer an)               -->
<!--     ‚Ä¢ Modulare Steuerung: VPet Bridge & Song Requests abschaltbar      -->
<!--     ‚Ä¢ KI-Antworten (!ask/!chat) bleiben l√§nger im Overlay              -->
<!--     ‚Ä¢ Verbessertes System Prompt mit Streamer- & Spielkontext          -->
<!--                                                                        -->
<!--   Copyright (c) 2025 J. Apps                                           -->
<!--   Licensed under the MIT License.                                      -->
<!-- ====================================================================== -->

<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Finja Bot Panel</title>

  <script src="https://cdn.jsdelivr.net/npm/comfy.js@1.1.1/dist/comfy.min.js  "></script>
  <script src="https://cdn.jsdelivr.net/npm/obs-websocket-js@5/dist/obs-ws.min.js  "></script>

  <style>
    :root{ --accent:#7aa2ff }
    *{ box-sizing: border-box }
    body{
      margin:0; padding:0;
      font:15px/1.4 Inter, system-ui, Arial;
      background:#0c0e14; color:#eaf1ff;
    }
    h2{ margin:16px 16px 0; color:var(--accent) }
    .card{ background:#121725; border:1px solid #263048; border-radius:12px; padding:14px; margin:16px }
    .row{ display:grid; grid-template-columns:1fr 1fr; gap:10px }
    label{ display:block; font-size:12px; opacity:.85; margin-top:8px }
    input, textarea{ width:100%; padding:8px 10px; border-radius:10px; border:1px solid #364057; background:#0b0f1a; color:#eaf1ff; font:inherit }
    textarea{ min-height: 80px; resize: vertical; }
    .btn{ display:inline-block; margin-top:10px; padding:10px 12px; border-radius:10px; background:#2a6cff; color:#fff; border:0; cursor:pointer }
    .btn.alt{ background:#444 }
    #log{ font-size:14px; line-height:1.4; padding:10px; max-height:320px; overflow:auto; white-space:pre-wrap; background:#0b0f1a; border:1px solid #2b3447; border-radius:10px }
    #log .ok{ color:#7df97d } #log .warn{ color:#ffd166 } #log .err{ color:#ff6b6b }
    code{ background:#0b0f1a; padding:2px 6px; border-radius:6px; border:1px solid #2b3447 }

    /* Pretty Commands Panel */
    .cmds {
      margin: 16px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 12px;
      padding: 12px 14px;
      color: #eaf1ff;
      font: 14px/1.4 Inter, system-ui, Arial;
    }
    .cmds .title {
      font-weight: 700; color: var(--accent,#7aa2ff); margin-bottom: 8px;
      display:flex; align-items:center; gap:8px;
    }
    .cmds .list { display: grid; gap: 8px 16px; grid-template-columns: 1fr 1fr; }
    .cmds .item { display:flex; gap:8px; align-items:flex-start; }
    .cmds .k {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.08);
      padding: 2px 6px; border-radius: 8px; white-space: nowrap;
    }
    .cmds .desc { opacity:.9 }
    .cmds .note {
      margin-top: 10px; opacity:.85; font-size: 13px;
      border-top: 1px dashed rgba(255,255,255,.12); padding-top: 10px;
    }
    .cmds .subgrid { display:grid; gap:6px }
    @media (max-width: 900px) { .cmds .list { grid-template-columns: 1fr; } }
  </style>
</head>
<body>

  <h2>Finja Bot Panel</h2>

  <div class="card">
    <div class="row">
      <div>
        <label>Channel</label>
        <input id="channel" placeholder="deinchannel" value="sodakiller1">
      </div>
      <div>
        <label>Bot Username</label>
        <input id="botuser" placeholder="finja_chat_bot" value="finja_chat_bot">
      </div>
    </div>
    <label>OAuth (Format: <code>oauth:xxxxxxxxxxxxxxxx</code>)</label>
    <input id="oauth" placeholder="oauth:..." type="password" />
    <button class="btn" id="connectBtn">Verbinden</button>
    <button class="btn alt" id="disconnectBtn">Trennen</button>
  </div>

  <div class="cmds">
    <div class="title">üß≠ Befehle</div>
    <div class="list">
      <div class="item"><div class="k">!ask | !chat</div><div class="desc">Stelle eine Frage an die KI ü§ñ</div></div>
      <div class="item"><div class="k">!help</div><div class="desc">√úbersicht (zeigt auch Overlay-Panel)</div></div>
      <div class="item"><div class="k">!drink</div><div class="desc">Finja bekommt was zu trinken ü•§</div></div>
      <div class="item"><div class="k">!uptime</div><div class="desc">Zeigt die Stream-Dauer an ‚è±Ô∏è</div></div>
      <div class="item"><div class="k">!theme</div><div class="desc">glass | dark | light | neon (neon auto-aktiviert <span class="k">rgb ring</span>)</div></div>
      <div class="item"><div class="k">!rgb</div><div class="desc">off | ring | fill | both ¬∑ <span class="k">!rgb ring <6-10></span></div></div>
      <div class="item"><div class="k">!rgbspeed</div><div class="desc">2-30 (Sekunden)</div></div>
      <div class="item"><div class="k">!ring</div><div class="desc">6-10 (Ringbreite)</div></div>
      <div class="item"><div class="k">!opacity</div><div class="desc">0-100</div></div>
      <div class="item"><div class="k">!pulse</div><div class="desc">on | off</div></div>
      <div class="item"><div class="k">!accent</div><div class="desc">finja | channel | custom #hex</div></div>
    </div>

    <div class="title" style="margin-top:12px">üéµ Song-Requests</div>
    <div class="subgrid">
      <div class="item"><div class="k">!sr</div><div class="desc">Viewer: <suche|link> (Spotify)</div></div>
      <div class="item"><div class="k">!rq</div><div class="desc">Mods: Liste W√ºnsche</div></div>
      <div class="item"><div class="k">!accept</div><div class="desc">Mods: <id> in Queue</div></div>
      <div class="item"><div class="k">!deny</div><div class="desc">Mods: <id> ablehnen</div></div>
    </div>
    <div class="note">
      Cooldown: 60s global + 60s/User (gilt <b>nicht</b> f√ºr <span class="k">!drink</span> und <span class="k">!ask</span>).
      <span class="k">Usage</span> verbraucht keinen Cooldown.
    </div>
  </div>

  <div class="card">
    <h2 style="margin:0 0 8px 0;color:#7aa2ff">ü§ñ LLM Chatbot (OpenWebUI)</h2>
    <label style="display:flex; align-items:center; gap:8px;">
      <input id="llm_enabled" type="checkbox" style="width:auto;"> LLM Chatbot aktivieren
    </label>

    <div class="row">
        <div>
            <label>OpenWebUI URL</label>
            <input id="llm_url" placeholder="http://localhost:3000">
        </div>
        <div>
            <label>Model ID</label>
            <input id="llm_model" placeholder="llama3:latest">
        </div>
    </div>
    <label>OpenWebUI API Key</label>
    <input id="llm_key" type="password" placeholder="Dein API Key...">

    <label>System Prompt (Anweisung f√ºr die KI)</label>
    <textarea id="llm_system_prompt">Du bist Finja, eine fr√∂hliche und hilfsbereite Katze und die Streamerin eines Twitch-Kanals. Antworte kurz, freundlich und direkt auf die Nachrichten der User im Chat. Sprich die User immer mit ihrem Namen an.</textarea>

    <button class="btn" id="llm_save_settings">Einstellungen speichern</button>
    <button class="btn alt" id="llm_clear_history">Chat-Ged√§chtnis l√∂schen</button>
  </div>

  <div class="card">
    <h2 style="margin:0 0 8px 0;color:#7aa2ff">OBS Sync</h2>
    <div class="row">
      <div>
        <label>OBS WS Adresse</label>
        <input id="obs_addr" placeholder="ws://127.0.0.1:4455" value="ws://127.0.0.1:4455">
      </div>
      <div>
        <label>OBS Passwort</label>
        <input id="obs_pass" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" type="password">
      </div>
    </div>
    <div class="row">
      <div>
        <label>Browser-Quelle (Name in OBS)</label>
        <input id="obs_input" placeholder="Finja Overlay">
      </div>
      <div>
        <label>Overlay-URL (Basis)</label>
        <input id="obs_overlay_url" placeholder="http://127.0.0.1:8088/index_merged.html">
        <small>Die Parameter (channel, theme, ‚Ä¶) h√§ngt der Bot automatisch an.</small>
      </div>
    </div>
    <button class="btn" id="obs_connect">OBS verbinden</button>
    <button class="btn alt" id="obs_disconnect">OBS trennen</button>
  </div>

  <div class="card">
    <h2 style="margin:0 0 8px 0;color:#7aa2ff">‚öôÔ∏è Einstellungen</h2>
    <div class="row">
      <div>
        <label style="display:flex; align-items:center; gap:8px;">
          <input id="vpet_enabled" type="checkbox" checked> VPet Bridge aktivieren
        </label>
      </div>
      <div>
        <label style="display:flex; align-items:center; gap:8px;">
          <input id="sr_enabled" type="checkbox" checked> Song-Requests aktivieren
        </label>
      </div>
    </div>
    <button class="btn" id="save_settings">Einstellungen speichern</button>
  </div>

  <div class="card">
    <div id="log"></div>
  </div>

<script>
/* ========== Helpers ========== */
const $ = (id)=>document.getElementById(id);
function nowHHMMSS(){ return new Date().toTimeString().slice(0,8); }
function toLogText(m){ try{ if(m instanceof Error) return `${m.name}: ${m.message}`; if(typeof m==="object") return JSON.stringify(m); return String(m);}catch{return String(m);} }
function log(m,cls=""){ const host=$("log"); if(!host) return; const row=document.createElement("div"); if(cls) row.className=cls; row.textContent=`[${nowHHMMSS()}] ${toLogText(m)}`; host.prepend(row); }

/* ========== Local storage defaults ========== */
$("oauth").value = localStorage.getItem("finja_bot_oauth") || "";
$("obs_addr").value = localStorage.getItem("finja_obs_addr") || "ws://127.0.0.1:4455";
$("obs_pass").value = localStorage.getItem("finja_obs_pass") || "";
$("obs_input").value = localStorage.getItem("finja_obs_input") || "";
$("obs_overlay_url").value = localStorage.getItem("finja_obs_overlay_url") || "";

/* ========== VPet Bridge Konfiguration ========== */
const VPET_BRIDGE_ENABLED = true; // Auf false setzen, um die Bridge zu deaktivieren
const VPET_BRIDGE_URL = "http://127.0.0.1:8091/command";

// Funktion zum Pr√ºfen, ob VPet aktiviert ist
const vpetEnabled = () => localStorage.getItem("finja_vpet_enabled") === 'true' || true;

async function sendToVpetBridge(command) {
  if (!vpetEnabled()) return;
  try {
    const response = await fetch(VPET_BRIDGE_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ command: command }),
    });
    if (response.ok) {
        log(`Befehl '${command}' erfolgreich an VPet-Bridge gesendet.`, 'ok');
    } else {
        log(`VPet-Bridge antwortet nicht (Status: ${response.status})`, 'warn');
    }
  } catch (error) {
    // Fehlermeldung nur loggen, wenn VPet aktiviert ist
    if (vpetEnabled()) {
      log(`VPet-Bridge nicht erreichbar: ${error.message}`, 'err');
    }
  }
}

/* ========== Broadcast Channel (Overlay in gleichem Browser) ========== */
let bc; try{ bc = new BroadcastChannel("finja-overlay"); }catch{}

/* ========== OBS WebSocket v5 ========== */
const obs = new OBSWebSocket();
let obsReady = false;

async function connectOBS(){
  const addr = $("obs_addr").value.trim() || "ws://127.0.0.1:4455";
  const pass = $("obs_pass").value;
  try{
    await obs.connect(addr, pass);
    obsReady = true;
    localStorage.setItem("finja_obs_addr", addr);
    localStorage.setItem("finja_obs_pass", pass);
    localStorage.setItem("finja_obs_input", $("obs_input").value.trim());
    localStorage.setItem("finja_obs_overlay_url", $("obs_overlay_url").value.trim());
    log(`OBS verbunden: ${addr}`, "ok");
  }catch(e){
    obsReady = false;
    log(`OBS connect failed: ${e?.message||e}`, "err");
  }
}
async function disconnectOBS(){ try{ await obs.disconnect(); }catch{} obsReady=false; log("OBS getrennt","warn"); }

/* ========== Overlay-State (f√ºr OBS-URL) ========== */
const OVERLAY = {
  channel: $("channel").value.trim().toLowerCase(),
  theme: "glass",
  rgbstyle: "off",
  rgbspeed: 8,
  ringw: 6,
  opacity: 70,
  accent: "finja",
  accentHex: "#7aa2ff",
  botname: "finja_chat_bot",
  confirm: null
};
function capRing(n){ if(!Number.isFinite(n)) return null; n=Math.round(n); return Math.min(10, Math.max(6, n)); }

/* ========== Build URL ‚Äì mit prevUrl + saved channel fallback ========== */
function buildOverlayUrl(prevUrl = null) {
  let base = $("obs_overlay_url").value.trim();
  if (!base) return null;
  if (!/^[a-z]+:\/\//i.test(base)) return null; // schema n√∂tig (http/https/file)

  const u = new URL(base);

  // Vorherige Parameter & gespeicherten Channel als Defaults nutzen
  const prev = new URLSearchParams(prevUrl ? new URL(prevUrl).search : "");
  const saved = (localStorage.getItem("finja_last_channel") || "").trim().toLowerCase();
  
  // Wichtig: Bot-Namen aus dem Input-Feld beziehen, damit er immer aktuell ist
  OVERLAY.botname = $("botuser").value.trim().toLowerCase() || "finja_chat_bot";

  const p = new URLSearchParams();
  const chan = (OVERLAY.channel || $("channel").value.trim().toLowerCase() || saved || prev.get("channel") || "").trim();

  if (!chan) {
    // Ohne Channel: Keine URL-√Ñnderung (nur Refresh)
    return null;
  }

  p.set("channel", chan);
  if (OVERLAY.theme)   p.set("theme", OVERLAY.theme);
  if (OVERLAY.accent)  p.set("accent", OVERLAY.accent);
  if (OVERLAY.opacity != null)  p.set("opacity", String(OVERLAY.opacity));
  if (OVERLAY.theme === "neon" && OVERLAY.rgbstyle) p.set("rgbstyle", OVERLAY.rgbstyle);
  if (OVERLAY.rgbspeed != null) p.set("rgbspeed", String(OVERLAY.rgbspeed));
  if (OVERLAY.ringw != null)    p.set("ringw", String(OVERLAY.ringw));
  if (OVERLAY.botname)          p.set("botname", OVERLAY.botname);
  if (OVERLAY.accent === "custom" && /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(OVERLAY.accentHex)) {
    p.set("hex", OVERLAY.accentHex);
  }
  if (OVERLAY.confirm) p.set("confirm", OVERLAY.confirm); // nur beim Verbinden genutzt

  // Cache-Bust
  p.set("v", Date.now().toString());

  u.search = "?" + p.toString();
  return u.toString();
}

/* ========== OBS-Quelle aktualisieren: prevUrl verwenden + safe refresh ========== */
async function refreshBrowserSource() {
  if (!obsReady) return;
  const inputName = $("obs_input").value.trim();
  if (!inputName){ log("OBS: Bitte Browser-Quellen-Name eintragen.","warn"); return; }

  // Aktuelle Settings lesen
  let got;
  try {
    got = await obs.call("GetInputSettings", { inputName });
  } catch (e) {
    log("OBS GetInputSettings fehlgeschlagen: " + (e?.message||e), "err");
    return;
  }
  const oldSettings = got?.inputSettings || {};
  const newSettings = { ...oldSettings };

  const prevUrl = oldSettings?.url || null;
  const newUrl = buildOverlayUrl(prevUrl); // <‚Äî prevUrl mitgeben

  if (newUrl) {
    newSettings.is_local_file = false; // URL-Modus erzwingen
    newSettings.url = newUrl;
    if ("local_file" in newSettings) delete newSettings.local_file;
    try {
      await obs.call("SetInputSettings", { inputName, inputSettings: newSettings, overlay: false });
      log("OBS: Quelle-URL aktualisiert", "ok");
    } catch (e) {
      log("OBS SetInputSettings fehlgeschlagen: " + (e?.message||e), "err");
    }
  }

  // In jedem Fall: Refresh-Button dr√ºcken
  try {
    await obs.call("PressInputPropertiesButton", { inputName, propertyName: "refreshnocache" });
    log("OBS: Browser-Quelle refreshed", "ok");
  } catch (e) {
    log("OBS Refresh fehlgeschlagen: " + (e?.message||e), "err");
  }
}

/* ========== sendVisual ‚Äì keine confirm-Meldungen f√ºr Commands ========== */
function sendVisual(cmd, arg, flags){
  // Overlay-State aktualisieren
  if (cmd==="theme"){
    const v=String(arg||"").toLowerCase();
    if (["glass","dark","light","neon"].includes(v)) OVERLAY.theme=v;
  }
  if (cmd==="rgb"){
    const v=String(arg||"").toLowerCase();
    if (["off","ring","fill","both"].includes(v)){
      OVERLAY.rgbstyle=v;
      if (v!=="off") OVERLAY.theme="neon";
    }
  }
  if (cmd==="rgbspeed"){ OVERLAY.rgbspeed = Math.max(2, Math.min(30, Number(arg)||8)); }
  if (cmd==="ring"){ const px = capRing(Number(arg)); if(px!=null) OVERLAY.ringw = px; }
  if (cmd==="opacity"){ OVERLAY.opacity = Math.max(0, Math.min(100, Number(arg)||70)); }
  if (cmd==="accent"){
    const parts = String(arg||"").trim().split(/\s+/);
    const mode = (parts[0]||"").toLowerCase();
    if (["finja","channel","custom"].includes(mode)){
      OVERLAY.accent = mode;
      if (mode==="custom" && parts[1] && /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(parts[1])) OVERLAY.accentHex = parts[1];
    }
  }

  // an Overlay im gleichen Browser
  try { bc?.postMessage({ type:"command", cmd, arg, flags }); } catch {}

  // Nur URL √§ndern, wenn Channel sicher vorhanden ‚Äì sonst nur Refresh
  const chan = OVERLAY.channel || $("channel").value.trim() || localStorage.getItem("finja_last_channel");
  if (!chan) {
    log("Kein Channel gesetzt ‚Äì nur Refresh, keine URL-√Ñnderung.","warn");
    refreshBrowserSource();
    return;
  }
  refreshBrowserSource();
}


/* ====================================================================== */
/* LLM Chatbot Logik (Version 2 mit User-spezifischem Ged√§chtnis)     */
/* ====================================================================== */

// Konfiguration f√ºr den LLM Chatbot
const LLM_CONFIG = {
    enabled: false,
    apiUrl: "",
    apiKey: "",
    modelId: "",
    systemPrompt: ""
};

// Ein Map-Objekt, um f√ºr jeden User eine eigene Chat-History zu speichern.
// Key = username, Value = Array mit Nachrichten
const userChatHistories = new Map();

// Funktion zum Laden der LLM-Einstellungen aus dem LocalStorage
function loadLlmSettings() {
    LLM_CONFIG.enabled = localStorage.getItem("finja_llm_enabled") === 'true';
    LLM_CONFIG.apiUrl = localStorage.getItem("finja_llm_apiUrl") || "";
    LLM_CONFIG.apiKey = localStorage.getItem("finja_llm_apiKey") || "";
    LLM_CONFIG.modelId = localStorage.getItem("finja_llm_modelId") || "";
    LLM_CONFIG.systemPrompt = localStorage.getItem("finja_llm_systemPrompt") || "Du bist Finja, eine fr√∂hliche und hilfsbereite Katze und die Streamerin eines Twitch-Kanals. Antworte kurz, freundlich und direkt auf die Nachrichten der User im Chat. Sprich die User immer mit ihrem Namen an.";

    // UI-Elemente mit den geladenen Werten f√ºllen
    $('llm_enabled').checked = LLM_CONFIG.enabled;
    $('llm_url').value = LLM_CONFIG.apiUrl;
    $('llm_key').value = LLM_CONFIG.apiKey;
    $('llm_model').value = LLM_CONFIG.modelId;
    $('llm_system_prompt').value = LLM_CONFIG.systemPrompt;
    log("LLM-Einstellungen geladen.", "ok");
}

// Funktion zum Speichern der LLM-Einstellungen
function saveLlmSettings() {
    LLM_CONFIG.enabled = $('llm_enabled').checked;
    LLM_CONFIG.apiUrl = $('llm_url').value.trim();
    LLM_CONFIG.apiKey = $('llm_key').value.trim();
    LLM_CONFIG.modelId = $('llm_model').value.trim();
    LLM_CONFIG.systemPrompt = $('llm_system_prompt').value.trim();

    localStorage.setItem("finja_llm_enabled", LLM_CONFIG.enabled);
    localStorage.setItem("finja_llm_apiUrl", LLM_CONFIG.apiUrl);
    localStorage.setItem("finja_llm_apiKey", LLM_CONFIG.apiKey);
    localStorage.setItem("finja_llm_modelId", LLM_CONFIG.modelId);
    localStorage.setItem("finja_llm_systemPrompt", LLM_CONFIG.systemPrompt);
    log("LLM-Einstellungen gespeichert.", "ok");
}

// Event-Listener f√ºr die UI-Buttons
$('llm_save_settings').onclick = saveLlmSettings;
$('llm_clear_history').onclick = () => {
    // L√∂scht jetzt die Ged√§chtnisse ALLER User
    userChatHistories.clear();
    log("Alle LLM Chat-Ged√§chtnisse gel√∂scht.", "warn");
};

// Hauptfunktion, um eine Anfrage an die LLM zu senden
async function askLlm(user, message) {
    if (!LLM_CONFIG.enabled) return;
    if (!LLM_CONFIG.apiUrl || !LLM_CONFIG.apiKey || !LLM_CONFIG.modelId) {
        log("LLM-Chatbot ist aktiviert, aber die Konfiguration ist unvollst√§ndig.", "err");
        return;
    }
    
    const username = user.toLowerCase();

    // Hole die History f√ºr diesen spezifischen User.
    // Wenn der User noch keine History hat, erstelle eine neue, leere.
    if (!userChatHistories.has(username)) {
        userChatHistories.set(username, []);
    }
    const currentUserHistory = userChatHistories.get(username);

    // Nachricht zum Verlauf des aktuellen Users hinzuf√ºgen
    currentUserHistory.push({ role: "user", content: message });

    // Verlauf k√ºrzen, um Token-Limit nicht zu sprengen (letzte 20 Nachrichten behalten)
    if (currentUserHistory.length > 20) {
        // Entfernt die √§ltesten Eintr√§ge, bis nur noch 20 √ºbrig sind
        userChatHistories.set(username, currentUserHistory.slice(-20));
    }

    // Nachrichten-Payload f√ºr die API erstellen
    const messagesPayload = [
        // Der System-Prompt enth√§lt jetzt auch den Namen des Users f√ºr zus√§tzlichen Kontext
        { role: "system", content: `${LLM_CONFIG.systemPrompt} Du sprichst gerade mit dem User '${user}'.` },
        ...currentUserHistory
    ];

    log(`Sende Anfrage an LLM f√ºr @${user}...`);

    try {
        const response = await fetch(`${LLM_CONFIG.apiUrl}/api/chat/completions`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${LLM_CONFIG.apiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                model: LLM_CONFIG.modelId,
                messages: messagesPayload,
                stream: false
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API-Fehler: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        const llmResponse = data.choices[0]?.message?.content;

        if (llmResponse) {
            log(`Antwort von LLM f√ºr @${user} erhalten: ${llmResponse}`, "ok");
            // KI-Antwort zum Verlauf des aktuellen Users hinzuf√ºgen
            currentUserHistory.push({ role: "assistant", content: llmResponse });
            // Antwort in den Twitch-Chat senden
            say(llmResponse.trim());
        } else {
            throw new Error("Leere oder ung√ºltige Antwort von der API erhalten.");
        }

    } catch (error) {
        log(`Fehler bei der LLM-Anfrage f√ºr @${user}: ${error.message}`, "err");
        say(`@${user}, Entschuldigung, mein Katzenhirn hat gerade einen Kurzschluss. üß†‚ö°`);
    }
}
// Lade die Einstellungen beim Start
document.addEventListener('DOMContentLoaded', loadLlmSettings);


/* ========== Cooldowns & Router ========== */
let connected = false;
let connectTime = null; // <-- NEU: Speichert den Zeitpunkt der Verbindung
const COOLDOWN_MS = 60_000; // 60s
const cdGlobal = Object.create(null);
const cdUser   = Object.create(null);
const now = ()=>Date.now();
function cooldownRemaining(cmd, userId){
  const g = cdGlobal[cmd] || 0;
  const u = cdUser[`${cmd}:${userId||"?"}`] || 0;
  const t = now();
  const remain = Math.max(0, COOLDOWN_MS - Math.max(t-g, t-u));
  return Math.ceil(remain/1000);
}
function startCooldown(cmd, userId){
  const t = now();
  cdGlobal[cmd] = t;
  cdUser[`${cmd}:${userId||"?"}`] = t;
}
function say(msg){ try{ ComfyJS.Say(msg); }catch(e){ log(`Say() failed: ${e}`,"err"); } }
const isPriv = (flags)=> !!(flags?.broadcaster || flags?.mod);

/* ‚Äî‚Äî‚Äî 3-teiliger !help ‚Äî‚Äî‚Äî */
function helpTriplet(){
  const line1 = "üß≠ Befehle: üíß !drink ¬∑ ü§ñ !ask | !chat <frage> (frage Finja etwas!)";
  const line2 = "‚ú® Visuals: !theme glass|dark|light|neon ¬∑ !rgb off|ring|fill|both ¬∑ !rgb ring <6-10> ¬∑ !rgbspeed 2-30 ¬∑ !ring 6-10 ¬∑ !opacity 0-100 ¬∑ !pulse on|off ¬∑ !accent finja|channel|custom #hex";
  const line3 = "üéµ Song-Requests: !sr <suche|link> ¬∑ Mods: !rq ¬∑ !accept <id> ¬∑ !deny <id> ¬∑ ‚è± Cooldown ~120s";
  setTimeout(()=>{ try{ say(line1); }catch{} }, 200);
  setTimeout(()=>{ try{ say(line2); }catch{} }, 1400);
  setTimeout(()=>{ try{ say(line3); }catch{} }, 2600);
  try{ (window.bc||new BroadcastChannel("finja-overlay")).postMessage({type:"help",title:"Befehle",lines:[line1,line2,line3],ttl:10000}); }catch{}
}

function handleCommand(user, cmd, arg, flags, extra){
  const uid = extra?.userId || (extra?.username||user||"").toLowerCase();
  OVERLAY.channel = $("channel").value.trim().toLowerCase();

  // --- Befehle OHNE Cooldown ---
  if (cmd==="help"){ helpTriplet(); return; }
  if (cmd==="drink"){ say("ü•§ Finja hat was zu trinken bekommen!"); sendToVpetBridge('drink'); return; }

  // --- NEU: !uptime Befehl ---
  if (cmd === "uptime") {
    if (!connected || !connectTime) {
      say(`@${user}, Finja ist gerade offline oder die Startzeit ist unbekannt.`);
      return;
    }
    const now = Date.now();
    const diff = now - connectTime; // <-- Jetzt verwenden wir unsere eigene Variable
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60) % 60;
    const hours = Math.floor(seconds / 3600);

    let uptimeText = "";
    if (hours > 0) uptimeText += `${hours}h `;
    uptimeText += `${minutes}m`;

    say(`@${user}, Finja streamt seit ${uptimeText}.`);
    return;
  }
  
  // --- LLM Chat Befehle ---
  if (cmd === "ask" || cmd === "chat") {
    if (!arg) { // Pr√ºfen, ob eine Nachricht vorhanden ist
      say(`@${user}, du musst mir schon eine Frage stellen! z.B. !ask Wie geht es dir?`);
      return;
    }
    // Wir √ºbergeben hier den originalen User-Namen mit Gro√ü/Kleinschreibung
    askLlm(user, arg); // Die LLM-Funktion aufrufen
    return; // Wichtig: Hier beenden, um nicht in die Cooldown-Logik zu laufen
  }

  // --- Befehle MIT Cooldown (nur f√ºr Mods/Broadcaster) ---
  if (!isPriv(flags)) return;
  function guardCooldown(name){ const rem=cooldownRemaining(name, uid); if(rem>0){ say(`‚è≥ Cooldown noch ${rem}s aktiv ‚Äì bitte warten`); return false; } return true; }
  function done(name){ startCooldown(name, uid); }

  if (cmd==="rgb"){
    const parts = String(arg||"").trim().split(/\s+/);
    if (parts[0]==="ring" && parts[1]){
      const raw = Number(parts[1]); const px = capRing(raw);
      if (px===null){ say("Usage: !rgb ring <6-10>"); return; }
      if (!guardCooldown("rgb")) return;
      sendVisual("ring", String(px), flags);
      sendVisual("rgb", "ring", flags);
      sendVisual("theme","neon",flags);
      setTimeout(()=>{ say(`RGB Ring ‚Üí ${px}px`); }, 5000);
      done("rgb"); return;
    }
    const v=(parts[0]||"").toLowerCase();
    if (!["off","ring","fill","both"].includes(v)){ say("Usage: !rgb off|ring|fill|both  (oder: !rgb ring <6-10>)"); return; }
    if (!guardCooldown("rgb")) return;
    sendVisual("rgb", v, flags);
    if (v!=="off") sendVisual("theme","neon",flags);
    setTimeout(()=>{ say(`RGB ‚Üí ${v}`); }, 5000);
    done("rgb"); return;
  }

  if (cmd==="rgbspeed"){
    const n = Math.max(2, Math.min(30, Number(arg)||0));
    if (!n){ say("Usage: !rgbspeed 2-30"); return; }
    if (!guardCooldown("rgbspeed")) return;
    sendVisual("rgbspeed", String(n), flags);
    setTimeout(()=>{ say(`RGB Speed ‚Üí ${n}s`); }, 5000);
    done("rgbspeed"); return;
  }

  if (cmd==="ring"){
    const px = capRing(Number(arg));
    if (px===null){ say("Usage: !ring 6-10"); return; }
    if (!guardCooldown("ring")) return;
    sendVisual("ring", String(px), flags);
    setTimeout(()=>{ say(`RGB Ring ‚Üí ${px}px`); }, 5000);
    done("ring"); return;
  }

  if (cmd==="opacity"){
    const v = Math.max(0, Math.min(100, Number(arg)||-1));
    if (v<0){ say("Usage: !opacity 0-100"); return; }
    if (!guardCooldown("opacity")) return;
    sendVisual("opacity", String(v), flags);
    setTimeout(()=>{ say(`Opacity ‚Üí ${v}%`); }, 4000);
    done("opacity"); return;
  }

  if (cmd==="pulse"){
    const on = (String(arg||"").toLowerCase()==="on");
    if (!["on","off"].includes(String(arg||"").toLowerCase())){ say("Usage: !pulse on|off"); return; }
    if (!guardCooldown("pulse")) return;
    // (Visual ggf. vom Overlay interpretiert, hier nur announce)
    setTimeout(()=>{ say(`RGB Pulse: ${on?"ON":"OFF"}`); }, 4000);
    done("pulse"); return;
  }

  if (cmd==="theme"){
    const v=(arg||"").toLowerCase();
    if (!["glass","dark","light","neon"].includes(v)){ say("Usage: !theme glass|dark|light|neon"); return; }
    if (!guardCooldown("theme")) return;
    sendVisual("theme", v, flags);
    // Chat erst sp√§ter, damit OBS/Browser stabil ist
    setTimeout(()=>{ say(`Theme ‚Üí ${v}`); }, 10000);
    done("theme"); return;
  }

  if (cmd==="accent"){
    const p = String(arg||"").trim().split(/\s+/);
    const mode = (p[0]||"").toLowerCase();
    const hex  = p[1] || "";
    if (!["finja","channel","custom"].includes(mode)){ say("Usage: !accent finja|channel|custom [#hex]"); return; }
    if (mode==="custom" && !/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(hex)){ say("Usage: !accent custom #rrggbb"); return; }
    if (!guardCooldown("accent")) return;
    sendVisual("accent", mode==="custom" ? `custom ${hex}` : mode, flags);
    setTimeout(()=>{ say(`Accent ‚Üí ${mode}${mode==="custom" ? " "+hex : ""}`); }, 6000);
    done("accent"); return;
  }
}

/* ========== ComfyJS Lifecycle ========== */
ComfyJS.onConnected = (addr,port,isSSL)=>{
  connected = true;
  connectTime = Date.now(); // <-- NEU: Speichere den Verbindungszeitpunkt
  log(`Verbunden: ${addr}:${port} (SSL:${isSSL})`,"ok");
  try{ ComfyJS.Say('Finja ist online ‚ú® & Layout zur√ºckgesetzt!'); }catch{}
};
ComfyJS.onReconnect = (n)=> log(`Reconnecting (#${n})`,"warn");
ComfyJS.onError = (err)=> {
  const msg = (err && err.message) ? err.message : String(err||"");
  if (msg.includes("channel:read:redemptions") || msg.includes("user:read:email")){
    log("Hinweis: Redemptions/Email-Scopes fehlen ‚Äì ignorierbar.", "warn");
  } else {
    log(`Fehler: ${msg}`, "err");
  }
};
ComfyJS.onChat = (user, message, flags, self, extra)=>{
  if (self) return;
  if (typeof message !== "string" || !message.startsWith("!")) return;
  const parts = message.trim().split(/\s+/);
  const cmd = parts[0].slice(1).toLowerCase();
  const arg = parts.slice(1).join(" ");
  handleCommand(user, cmd, arg, flags, extra);
};
ComfyJS.onCommand = (user, command, message, flags, extra)=>{
  handleCommand(user, String(command||"").toLowerCase(), message||"", flags, extra);
};

/* ========== Connect/Disconnect UI ========== */
$("obs_connect").onclick = connectOBS;
$("obs_disconnect").onclick = disconnectOBS;

$("connectBtn").onclick = ()=>{
  if (connected) return;
  const channel = $("channel").value.trim().toLowerCase();
  const botuser = $("botuser").value.trim().toLowerCase();
  let oauth = $("oauth").value.trim();

  if (!channel || !botuser || !oauth){ log("Bitte Channel, Bot-User und OAuth ausf√ºllen.","warn"); return; }
  if (!/^oauth:[a-z0-9]+$/i.test(oauth)){ log("OAuth muss mit 'oauth:' beginnen.","warn"); return; }

  localStorage.setItem("finja_bot_oauth", oauth);

  try{
    // Comfy verbinden + Channel merken
    ComfyJS.Init(botuser, oauth, channel);
    localStorage.setItem("finja_last_channel", channel);
    OVERLAY.channel = channel;

    // einmalige Start-Confirm ins Overlay (ok f√ºr Doppelpost, weils nur 1x ist)
    refreshBrowserSource();
    log(`Verbinde als @${botuser} in #${channel} ...`, "ok");
  }catch(e){
    log(`Init Fehler: ${e}`,"err");
  }
};
$("disconnectBtn").onclick = ()=>{
  try{ ComfyJS.Disconnect?.(); connected=false; log("Getrennt.","warn"); }catch{}
};

/* ========== Neue Einstellungen speichern ========== */
document.addEventListener('DOMContentLoaded', function() {
  $('vpet_enabled').checked = localStorage.getItem("finja_vpet_enabled") === 'true' || true;
  $('sr_enabled').checked = localStorage.getItem("finja_sr_enabled") === 'true' || true;
});

$('save_settings').onclick = function() {
  localStorage.setItem("finja_vpet_enabled", $('vpet_enabled').checked);
  localStorage.setItem("finja_sr_enabled", $('sr_enabled').checked);
  log("Einstellungen gespeichert.", "ok");
};

// Funktion zum Pr√ºfen, ob Song Requests aktiviert sind
const srEnabled = () => localStorage.getItem("finja_sr_enabled") === 'true';
</script>

<script>
(() => {
  const SR_ENDPOINT = "http://127.0.0.1:8099/chat";
  const SR_ALIASES = new Set(["sr","songrequest","queue","q","accept","deny","rq","requests","pending"]);
  const SR_REQUEST_CMDS = new Set(["sr","songrequest","queue","q"]);

  // Nur wenn SR aktiviert ist
  if (!srEnabled()) return;

  // Local cooldown (client-side), default 120s, overridable via ?srcd=<seconds>
  const qs = new URLSearchParams(location.search||"");
  const LOCAL_CD_MS = Math.max(0, (parseInt(qs.get("srcd") || "120", 10) || 120) * 1000);
  const lastByUser = new Map();
  function onLocalCooldown(user, flags){
    if (!LOCAL_CD_MS) return false;
    if (flags && (flags.mod || flags.broadcaster)) return false; // mods/broadcaster bypass
    const u = String(user||"").toLowerCase();
    const now = Date.now();
    const t = lastByUser.get(u) || 0;
    if (now - t < LOCAL_CD_MS) return true;
    lastByUser.set(u, now);
    return false;
  }

  // Chat output helper (chat if possible, else overlay BC -> index.html)
  const botname = (window.OVERLAY && window.OVERLAY.botname) || "finja_chat_bot";
  let bc;
  try { bc = window.bc || new BroadcastChannel("finja-overlay"); } catch {}

  function sayOrOverlay(text){
    let said = false;
    try { if (typeof ComfyJS.Say === "function") { ComfyJS.Say(text); said = true; } } catch {}
    if (!said && bc){
      try { bc.postMessage({ type:"chat", user: botname, message: text, flags:{ broadcaster:true }, extra:{ displayName: botname } }); } catch {}
    }
  }
  function finjaCooldownText(user){
    const secs = Math.max(1, Math.round(LOCAL_CD_MS/1000));
    return `üí§ Finja: Kurz mal durchatmen, ${user}! Alle ${secs}s ist ein Wunsch drin.`;
  }

  async function sendToSR(user, cmd, arg, flags){
    const payload = {
      user: String(user||""),
      message: `!${cmd}` + (arg ? ` ${arg}` : ""),
      is_mod: !!(flags && (flags.mod || flags.broadcaster)),
      is_broadcaster: !!(flags && flags.broadcaster)
    };
    try{
      const res = await fetch(SR_ENDPOINT, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(payload)
      });
      const data = await res.json().catch(()=>({}));
      if (data && data.finja) {
        // direkt in den Chat posten (und optional zus√§tzlich ins Overlay, wenn du willst)
        try { ComfyJS.Say(String(data.finja)); } catch {
          // Fallback: Overlay anzeigen, falls Chat-Send nicht geht
          if (bc) try { bc.postMessage({ type:"sr-announce", text: String(data.finja) }); } catch {}
        }
      } else if (data && data.reply) {
        // Fallback nur wenn KEIN finja-Text vorhanden ist
        sayOrOverlay(String(data.reply));
      }
    }catch(e){
      console.warn("[SR] fetch failed:", e);
      sayOrOverlay("‚ö†Ô∏è Finja SR: Der Server antwortet nicht.");
    }
  }

  // Intercept onCommand to add extras and handle SR aliases
  const prevOnCommand = ComfyJS.onCommand;
  ComfyJS.onCommand = (user, command, message, flags, extra) => {
    const cmd = String(command||"").toLowerCase();
    const arg = String(message||"");

    // Let existing handler run first for most commands
    if (typeof prevOnCommand === "function") {
      try { prevOnCommand(user, command, message, flags, extra); } catch(e) { console.error(e); }
    }

    // Theme extras: neon -> auto RGB ring + re-apply accent to keep rim
    if (cmd === "theme"){
      setTimeout(() => {
        try{
          if (arg.trim().toLowerCase() === "neon") {
            sendVisual("rgb", "ring", flags);
          }
          const accMode = (OVERLAY && OVERLAY.accent) || "finja";
          const accHex  = (OVERLAY && OVERLAY.accentHex) || "";
          sendVisual("accent", `${accMode}${accMode==="custom" && accHex ? " "+accHex : ""}`, flags);
        }catch(e){ console.warn("theme extras failed", e); }
      }, 50);
      return;
    }

    if (cmd === "help"){ return; } // SR-Bridge sendet kein Help (zentraler Help-Block √ºbernimmt)
    if (cmd === "ask" || cmd === "chat") { return; } // Wird schon von handleCommand behandelt
    if (cmd === "uptime") { return; } // Wird schon von handleCommand behandelt

    if (SR_ALIASES.has(cmd)) {
      if (SR_REQUEST_CMDS.has(cmd) && onLocalCooldown(user, flags)) {
        try { sayOrOverlay(finjaCooldownText(user)); } catch(_){}
        return;
      }
      sendToSR(user, cmd, arg, flags);
      return;
    }
  };

  // Also handle raw onChat to catch plain "!sr text" if onCommand isn't emitted
  const prevOnChat = ComfyJS.onChat;
  ComfyJS.onChat = (user, message, flags, self, extra) => {
    if (!self && typeof message === "string" && message.trim().startsWith("!")){
      const parts = message.trim().split(/\s+/);
      const name = parts[0].slice(1).toLowerCase();
      const rest = parts.slice(1).join(" ");
      if (SR_ALIASES.has(name)) {
        if (SR_REQUEST_CMDS.has(name) && onLocalCooldown(user, flags)) {
          try { sayOrOverlay(finjaCooldownText(user)); } catch(_){}
          return;
        }
        sendToSR(user, name, rest, flags);
        return;
      }
    }
    if (typeof prevOnChat === "function") {
      try { prevOnChat(user, message, flags, self, extra); } catch(e){ console.error(e); }
    }
  };
})();
</script>
<script>
(function(){
  try {
    const bc = new BroadcastChannel("finja-overlay");
    bc.onmessage = (ev) => {
      const data = ev.data || {};
      if (data.type === "sr-announce" && data.text && typeof ComfyJS.Say === "function"){
        try { ComfyJS.Say(data.text); } catch(e){ console.warn("Say failed:", e); }
      }
    };
  } catch {}
})();
</script>

</body>
</html>